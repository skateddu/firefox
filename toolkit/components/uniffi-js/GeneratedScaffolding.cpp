/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */

// Generated by uniffi-bindgen-gecko-js.  DO NOT EDIT.

#include "nsString.h"
#include "nsPrintfCString.h"
#include "mozilla/Logging.h"
#include "mozilla/StaticPtr.h"
#include "mozilla/dom/Promise.h"
#include "mozilla/dom/PromiseNativeHandler.h"
#include "mozilla/dom/UniFFIScaffolding.h"
#include "mozilla/uniffi/Call.h"
#include "mozilla/uniffi/Callbacks.h"
#include "mozilla/uniffi/FfiValue.h"
#include "mozilla/uniffi/PointerType.h"
#include "mozilla/uniffi/Rust.h"

namespace mozilla::uniffi {

using dom::ArrayBuffer;
using dom::AutoEntryScript;
using dom::GlobalObject;
using dom::RootedDictionary;
using dom::NullableRootedUnion;
using dom::Promise;
using dom::PromiseNativeHandler;
using dom::Sequence;
using dom::UniFFICallbackHandler;
using dom::UniFFIPointer;
using dom::UniFFIScaffoldingCallCode;
using dom::UniFFIScaffoldingCallResult;


/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

extern "C" {

  RustBuffer ffi_context_id_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_context_id_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_context_id_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_context_id_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  typedef void (*RustFutureContinuationCallback)(uint64_t, int8_t);
  typedef void (*ForeignFutureDroppedCallback)(uint64_t);
  struct ForeignFutureDroppedCallbackStruct {
    uint64_t handle;
    ForeignFutureDroppedCallback free;
  };
  void ffi_context_id_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_context_id_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_u8(uint64_t);
  void ffi_context_id_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_i8(uint64_t);
  int8_t ffi_context_id_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_i8(uint64_t);
  void ffi_context_id_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_context_id_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_u16(uint64_t);
  void ffi_context_id_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_i16(uint64_t);
  int16_t ffi_context_id_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_i16(uint64_t);
  void ffi_context_id_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_context_id_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_u32(uint64_t);
  void ffi_context_id_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_i32(uint64_t);
  int32_t ffi_context_id_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_i32(uint64_t);
  void ffi_context_id_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_context_id_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_u64(uint64_t);
  void ffi_context_id_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_i64(uint64_t);
  int64_t ffi_context_id_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_i64(uint64_t);
  void ffi_context_id_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_f32(uint64_t);
  float ffi_context_id_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_f32(uint64_t);
  void ffi_context_id_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_f64(uint64_t);
  double ffi_context_id_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_f64(uint64_t);
  void ffi_context_id_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_context_id_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_rust_buffer(uint64_t);
  void ffi_context_id_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_void(uint64_t);
  void ffi_context_id_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_void(uint64_t);
  uint64_t uniffi_context_id_fn_clone_contextidcomponent(uint64_t, RustCallStatus*);
  void uniffi_context_id_fn_free_contextidcomponent(uint64_t, RustCallStatus*);
  typedef void (*CallbackInterfaceContextIdContextIdCallbackMethod0)(uint64_t, RustBuffer, int64_t, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceContextIdContextIdCallbackMethod1)(uint64_t, RustBuffer, void*, RustCallStatus*);
  typedef uint64_t (*CallbackInterfaceCloneContextId_ContextIdCallback)(uint64_t);
  typedef void (*CallbackInterfaceFreeContextId_ContextIdCallback)(uint64_t);
  struct VTableCallbackInterfaceContextIdContextIdCallback {
    CallbackInterfaceFreeContextId_ContextIdCallback uniffi_free;
    CallbackInterfaceCloneContextId_ContextIdCallback uniffi_clone;
    CallbackInterfaceContextIdContextIdCallbackMethod0 persist;
    CallbackInterfaceContextIdContextIdCallbackMethod1 rotated;
  };
  void uniffi_context_id_fn_init_callback_vtable_contextidcallback(VTableCallbackInterfaceContextIdContextIdCallback*);
  uint64_t uniffi_context_id_fn_constructor_contextidcomponent_new(RustBuffer, int64_t, int8_t, uint64_t, RustCallStatus*);
  void uniffi_context_id_fn_method_contextidcomponent_force_rotation(uint64_t, RustCallStatus*);
  RustBuffer uniffi_context_id_fn_method_contextidcomponent_request(uint64_t, uint8_t, RustCallStatus*);
  void uniffi_context_id_fn_method_contextidcomponent_unset_callback(uint64_t, RustCallStatus*);
  uint32_t ffi_context_id_uniffi_contract_version();
  uint16_t uniffi_context_id_checksum_constructor_contextidcomponent_new();
  uint16_t uniffi_context_id_checksum_method_contextidcomponent_force_rotation();
  uint16_t uniffi_context_id_checksum_method_contextidcomponent_request();
  uint16_t uniffi_context_id_checksum_method_contextidcomponent_unset_callback();
  RustBuffer ffi_error_support_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_error_support_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_error_support_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_error_support_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_error_support_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_u8(uint64_t);
  void ffi_error_support_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_i8(uint64_t);
  int8_t ffi_error_support_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_i8(uint64_t);
  void ffi_error_support_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_error_support_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_u16(uint64_t);
  void ffi_error_support_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_i16(uint64_t);
  int16_t ffi_error_support_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_i16(uint64_t);
  void ffi_error_support_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_error_support_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_u32(uint64_t);
  void ffi_error_support_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_i32(uint64_t);
  int32_t ffi_error_support_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_i32(uint64_t);
  void ffi_error_support_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_error_support_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_u64(uint64_t);
  void ffi_error_support_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_i64(uint64_t);
  int64_t ffi_error_support_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_i64(uint64_t);
  void ffi_error_support_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_f32(uint64_t);
  float ffi_error_support_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_f32(uint64_t);
  void ffi_error_support_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_f64(uint64_t);
  double ffi_error_support_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_f64(uint64_t);
  void ffi_error_support_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_error_support_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_rust_buffer(uint64_t);
  void ffi_error_support_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_void(uint64_t);
  void ffi_error_support_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_void(uint64_t);
  uint32_t ffi_error_support_uniffi_contract_version();
  RustBuffer ffi_filter_adult_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_filter_adult_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_filter_adult_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_filter_adult_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_filter_adult_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_filter_adult_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_filter_adult_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_filter_adult_rust_future_free_u8(uint64_t);
  void ffi_filter_adult_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_filter_adult_rust_future_cancel_i8(uint64_t);
  int8_t ffi_filter_adult_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_filter_adult_rust_future_free_i8(uint64_t);
  void ffi_filter_adult_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_filter_adult_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_filter_adult_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_filter_adult_rust_future_free_u16(uint64_t);
  void ffi_filter_adult_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_filter_adult_rust_future_cancel_i16(uint64_t);
  int16_t ffi_filter_adult_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_filter_adult_rust_future_free_i16(uint64_t);
  void ffi_filter_adult_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_filter_adult_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_filter_adult_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_filter_adult_rust_future_free_u32(uint64_t);
  void ffi_filter_adult_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_filter_adult_rust_future_cancel_i32(uint64_t);
  int32_t ffi_filter_adult_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_filter_adult_rust_future_free_i32(uint64_t);
  void ffi_filter_adult_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_filter_adult_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_filter_adult_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_filter_adult_rust_future_free_u64(uint64_t);
  void ffi_filter_adult_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_filter_adult_rust_future_cancel_i64(uint64_t);
  int64_t ffi_filter_adult_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_filter_adult_rust_future_free_i64(uint64_t);
  void ffi_filter_adult_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_filter_adult_rust_future_cancel_f32(uint64_t);
  float ffi_filter_adult_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_filter_adult_rust_future_free_f32(uint64_t);
  void ffi_filter_adult_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_filter_adult_rust_future_cancel_f64(uint64_t);
  double ffi_filter_adult_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_filter_adult_rust_future_free_f64(uint64_t);
  void ffi_filter_adult_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_filter_adult_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_filter_adult_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_filter_adult_rust_future_free_rust_buffer(uint64_t);
  void ffi_filter_adult_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_filter_adult_rust_future_cancel_void(uint64_t);
  void ffi_filter_adult_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_filter_adult_rust_future_free_void(uint64_t);
  uint64_t uniffi_filter_adult_fn_clone_filteradultcomponent(uint64_t, RustCallStatus*);
  void uniffi_filter_adult_fn_free_filteradultcomponent(uint64_t, RustCallStatus*);
  uint64_t uniffi_filter_adult_fn_constructor_filteradultcomponent_new(RustCallStatus*);
  int8_t uniffi_filter_adult_fn_method_filteradultcomponent_contains(uint64_t, RustBuffer, RustCallStatus*);
  uint32_t ffi_filter_adult_uniffi_contract_version();
  uint16_t uniffi_filter_adult_checksum_constructor_filteradultcomponent_new();
  uint16_t uniffi_filter_adult_checksum_method_filteradultcomponent_contains();
  RustBuffer ffi_init_rust_components_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_init_rust_components_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_init_rust_components_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_init_rust_components_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_init_rust_components_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_init_rust_components_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_init_rust_components_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_init_rust_components_rust_future_free_u8(uint64_t);
  void ffi_init_rust_components_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_init_rust_components_rust_future_cancel_i8(uint64_t);
  int8_t ffi_init_rust_components_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_init_rust_components_rust_future_free_i8(uint64_t);
  void ffi_init_rust_components_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_init_rust_components_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_init_rust_components_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_init_rust_components_rust_future_free_u16(uint64_t);
  void ffi_init_rust_components_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_init_rust_components_rust_future_cancel_i16(uint64_t);
  int16_t ffi_init_rust_components_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_init_rust_components_rust_future_free_i16(uint64_t);
  void ffi_init_rust_components_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_init_rust_components_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_init_rust_components_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_init_rust_components_rust_future_free_u32(uint64_t);
  void ffi_init_rust_components_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_init_rust_components_rust_future_cancel_i32(uint64_t);
  int32_t ffi_init_rust_components_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_init_rust_components_rust_future_free_i32(uint64_t);
  void ffi_init_rust_components_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_init_rust_components_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_init_rust_components_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_init_rust_components_rust_future_free_u64(uint64_t);
  void ffi_init_rust_components_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_init_rust_components_rust_future_cancel_i64(uint64_t);
  int64_t ffi_init_rust_components_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_init_rust_components_rust_future_free_i64(uint64_t);
  void ffi_init_rust_components_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_init_rust_components_rust_future_cancel_f32(uint64_t);
  float ffi_init_rust_components_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_init_rust_components_rust_future_free_f32(uint64_t);
  void ffi_init_rust_components_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_init_rust_components_rust_future_cancel_f64(uint64_t);
  double ffi_init_rust_components_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_init_rust_components_rust_future_free_f64(uint64_t);
  void ffi_init_rust_components_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_init_rust_components_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_init_rust_components_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_init_rust_components_rust_future_free_rust_buffer(uint64_t);
  void ffi_init_rust_components_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_init_rust_components_rust_future_cancel_void(uint64_t);
  void ffi_init_rust_components_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_init_rust_components_rust_future_free_void(uint64_t);
  void uniffi_init_rust_components_fn_func_initialize(RustBuffer, RustCallStatus*);
  uint32_t ffi_init_rust_components_uniffi_contract_version();
  uint16_t uniffi_init_rust_components_checksum_func_initialize();
  RustBuffer ffi_logins_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_logins_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_logins_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_logins_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_logins_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_logins_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_logins_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_logins_rust_future_free_u8(uint64_t);
  void ffi_logins_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_logins_rust_future_cancel_i8(uint64_t);
  int8_t ffi_logins_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_logins_rust_future_free_i8(uint64_t);
  void ffi_logins_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_logins_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_logins_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_logins_rust_future_free_u16(uint64_t);
  void ffi_logins_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_logins_rust_future_cancel_i16(uint64_t);
  int16_t ffi_logins_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_logins_rust_future_free_i16(uint64_t);
  void ffi_logins_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_logins_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_logins_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_logins_rust_future_free_u32(uint64_t);
  void ffi_logins_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_logins_rust_future_cancel_i32(uint64_t);
  int32_t ffi_logins_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_logins_rust_future_free_i32(uint64_t);
  void ffi_logins_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_logins_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_logins_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_logins_rust_future_free_u64(uint64_t);
  void ffi_logins_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_logins_rust_future_cancel_i64(uint64_t);
  int64_t ffi_logins_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_logins_rust_future_free_i64(uint64_t);
  void ffi_logins_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_logins_rust_future_cancel_f32(uint64_t);
  float ffi_logins_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_logins_rust_future_free_f32(uint64_t);
  void ffi_logins_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_logins_rust_future_cancel_f64(uint64_t);
  double ffi_logins_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_logins_rust_future_free_f64(uint64_t);
  void ffi_logins_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_logins_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_logins_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_logins_rust_future_free_rust_buffer(uint64_t);
  void ffi_logins_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_logins_rust_future_cancel_void(uint64_t);
  void ffi_logins_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_logins_rust_future_free_void(uint64_t);
  uint64_t uniffi_logins_fn_clone_encryptordecryptor(uint64_t, RustCallStatus*);
  void uniffi_logins_fn_free_encryptordecryptor(uint64_t, RustCallStatus*);
  uint64_t uniffi_logins_fn_clone_keymanager(uint64_t, RustCallStatus*);
  void uniffi_logins_fn_free_keymanager(uint64_t, RustCallStatus*);
  uint64_t uniffi_logins_fn_clone_loginstore(uint64_t, RustCallStatus*);
  void uniffi_logins_fn_free_loginstore(uint64_t, RustCallStatus*);
  uint64_t uniffi_logins_fn_clone_managedencryptordecryptor(uint64_t, RustCallStatus*);
  void uniffi_logins_fn_free_managedencryptordecryptor(uint64_t, RustCallStatus*);
  uint64_t uniffi_logins_fn_clone_nsskeymanager(uint64_t, RustCallStatus*);
  void uniffi_logins_fn_free_nsskeymanager(uint64_t, RustCallStatus*);
  uint64_t uniffi_logins_fn_clone_primarypasswordauthenticator(uint64_t, RustCallStatus*);
  void uniffi_logins_fn_free_primarypasswordauthenticator(uint64_t, RustCallStatus*);
  uint64_t uniffi_logins_fn_clone_statickeymanager(uint64_t, RustCallStatus*);
  void uniffi_logins_fn_free_statickeymanager(uint64_t, RustCallStatus*);
  typedef void (*CallbackInterfaceLoginsEncryptorDecryptorMethod0)(uint64_t, RustBuffer, RustBuffer*, RustCallStatus*);
  typedef void (*CallbackInterfaceLoginsEncryptorDecryptorMethod1)(uint64_t, RustBuffer, RustBuffer*, RustCallStatus*);
  typedef uint64_t (*CallbackInterfaceCloneLogins_EncryptorDecryptor)(uint64_t);
  typedef void (*CallbackInterfaceFreeLogins_EncryptorDecryptor)(uint64_t);
  struct VTableCallbackInterfaceLoginsEncryptorDecryptor {
    CallbackInterfaceFreeLogins_EncryptorDecryptor uniffi_free;
    CallbackInterfaceCloneLogins_EncryptorDecryptor uniffi_clone;
    CallbackInterfaceLoginsEncryptorDecryptorMethod0 decrypt;
    CallbackInterfaceLoginsEncryptorDecryptorMethod1 encrypt;
  };
  void uniffi_logins_fn_init_callback_vtable_encryptordecryptor(VTableCallbackInterfaceLoginsEncryptorDecryptor*);
  typedef void (*CallbackInterfaceLoginsKeyManagerMethod0)(uint64_t, RustBuffer*, RustCallStatus*);
  typedef uint64_t (*CallbackInterfaceCloneLogins_KeyManager)(uint64_t);
  typedef void (*CallbackInterfaceFreeLogins_KeyManager)(uint64_t);
  struct VTableCallbackInterfaceLoginsKeyManager {
    CallbackInterfaceFreeLogins_KeyManager uniffi_free;
    CallbackInterfaceCloneLogins_KeyManager uniffi_clone;
    CallbackInterfaceLoginsKeyManagerMethod0 get_key;
  };
  void uniffi_logins_fn_init_callback_vtable_keymanager(VTableCallbackInterfaceLoginsKeyManager*);
  struct ForeignFutureResultRustBuffer {
    RustBuffer return_value;
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompleterust_buffer)(uint64_t, ForeignFutureResultRustBuffer);
  typedef void (*CallbackInterfaceLoginsPrimaryPasswordAuthenticatorMethod0)(uint64_t, ForeignFutureCompleterust_buffer, uint64_t, ForeignFutureDroppedCallbackStruct*);
  struct ForeignFutureResultVoid {
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompletevoid)(uint64_t, ForeignFutureResultVoid);
  typedef void (*CallbackInterfaceLoginsPrimaryPasswordAuthenticatorMethod1)(uint64_t, ForeignFutureCompletevoid, uint64_t, ForeignFutureDroppedCallbackStruct*);
  typedef void (*CallbackInterfaceLoginsPrimaryPasswordAuthenticatorMethod2)(uint64_t, ForeignFutureCompletevoid, uint64_t, ForeignFutureDroppedCallbackStruct*);
  typedef uint64_t (*CallbackInterfaceCloneLogins_PrimaryPasswordAuthenticator)(uint64_t);
  typedef void (*CallbackInterfaceFreeLogins_PrimaryPasswordAuthenticator)(uint64_t);
  struct VTableCallbackInterfaceLoginsPrimaryPasswordAuthenticator {
    CallbackInterfaceFreeLogins_PrimaryPasswordAuthenticator uniffi_free;
    CallbackInterfaceCloneLogins_PrimaryPasswordAuthenticator uniffi_clone;
    CallbackInterfaceLoginsPrimaryPasswordAuthenticatorMethod0 get_primary_password;
    CallbackInterfaceLoginsPrimaryPasswordAuthenticatorMethod1 on_authentication_success;
    CallbackInterfaceLoginsPrimaryPasswordAuthenticatorMethod2 on_authentication_failure;
  };
  void uniffi_logins_fn_init_callback_vtable_primarypasswordauthenticator(VTableCallbackInterfaceLoginsPrimaryPasswordAuthenticator*);
  int8_t uniffi_logins_fn_func_check_canary(RustBuffer, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_func_create_canary(RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_func_create_key(RustCallStatus*);
  uint64_t uniffi_logins_fn_func_create_login_store_with_nss_keymanager(RustBuffer, uint64_t, RustCallStatus*);
  uint64_t uniffi_logins_fn_func_create_login_store_with_static_key_manager(RustBuffer, RustBuffer, RustCallStatus*);
  uint64_t uniffi_logins_fn_func_create_managed_encdec(uint64_t, RustCallStatus*);
  uint64_t uniffi_logins_fn_func_create_static_key_manager(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_encryptordecryptor_decrypt(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_encryptordecryptor_encrypt(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_keymanager_get_key(uint64_t, RustCallStatus*);
  uint64_t uniffi_logins_fn_constructor_loginstore_new(RustBuffer, uint64_t, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_loginstore_add(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_loginstore_add_many(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_loginstore_add_many_with_meta(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_loginstore_add_or_update(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_loginstore_add_with_meta(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_loginstore_are_potentially_vulnerable_passwords(uint64_t, RustBuffer, RustCallStatus*);
  int64_t uniffi_logins_fn_method_loginstore_count(uint64_t, RustCallStatus*);
  int64_t uniffi_logins_fn_method_loginstore_count_by_form_action_origin(uint64_t, RustBuffer, RustCallStatus*);
  int64_t uniffi_logins_fn_method_loginstore_count_by_origin(uint64_t, RustBuffer, RustCallStatus*);
  int8_t uniffi_logins_fn_method_loginstore_delete(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_loginstore_delete_many(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_loginstore_delete_undecryptable_records_for_remote_replacement(uint64_t, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_loginstore_find_login_to_update(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_loginstore_get(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_loginstore_get_by_base_domain(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_loginstore_get_checkpoint(uint64_t, RustCallStatus*);
  int8_t uniffi_logins_fn_method_loginstore_has_logins_by_base_domain(uint64_t, RustBuffer, RustCallStatus*);
  int8_t uniffi_logins_fn_method_loginstore_is_breach_alert_dismissed(uint64_t, RustBuffer, RustCallStatus*);
  int8_t uniffi_logins_fn_method_loginstore_is_empty(uint64_t, RustCallStatus*);
  int8_t uniffi_logins_fn_method_loginstore_is_potentially_breached(uint64_t, RustBuffer, RustCallStatus*);
  int8_t uniffi_logins_fn_method_loginstore_is_potentially_vulnerable_password(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_loginstore_list(uint64_t, RustCallStatus*);
  void uniffi_logins_fn_method_loginstore_record_breach(uint64_t, RustBuffer, int64_t, RustCallStatus*);
  void uniffi_logins_fn_method_loginstore_record_breach_alert_dismissal(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_logins_fn_method_loginstore_record_breach_alert_dismissal_time(uint64_t, RustBuffer, int64_t, RustCallStatus*);
  void uniffi_logins_fn_method_loginstore_record_potentially_vulnerable_passwords(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_logins_fn_method_loginstore_register_with_sync_manager(uint64_t, RustCallStatus*);
  void uniffi_logins_fn_method_loginstore_reset(uint64_t, RustCallStatus*);
  void uniffi_logins_fn_method_loginstore_reset_all_breaches(uint64_t, RustCallStatus*);
  void uniffi_logins_fn_method_loginstore_run_maintenance(uint64_t, RustCallStatus*);
  void uniffi_logins_fn_method_loginstore_set_checkpoint(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_logins_fn_method_loginstore_shutdown(uint64_t, RustCallStatus*);
  void uniffi_logins_fn_method_loginstore_touch(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_logins_fn_method_loginstore_update(uint64_t, RustBuffer, RustBuffer, RustCallStatus*);
  void uniffi_logins_fn_method_loginstore_wipe_local(uint64_t, RustCallStatus*);
  uint64_t uniffi_logins_fn_constructor_managedencryptordecryptor_new(uint64_t, RustCallStatus*);
  uint64_t uniffi_logins_fn_constructor_nsskeymanager_new(uint64_t, RustCallStatus*);
  uint64_t uniffi_logins_fn_method_nsskeymanager_into_dyn_key_manager(uint64_t, RustCallStatus*);
  uint64_t uniffi_logins_fn_method_primarypasswordauthenticator_get_primary_password(uint64_t);
  uint64_t uniffi_logins_fn_method_primarypasswordauthenticator_on_authentication_success(uint64_t);
  uint64_t uniffi_logins_fn_method_primarypasswordauthenticator_on_authentication_failure(uint64_t);
  uint64_t uniffi_logins_fn_constructor_statickeymanager_new(RustBuffer, RustCallStatus*);
  uint32_t ffi_logins_uniffi_contract_version();
  uint16_t uniffi_logins_checksum_func_check_canary();
  uint16_t uniffi_logins_checksum_func_create_canary();
  uint16_t uniffi_logins_checksum_func_create_key();
  uint16_t uniffi_logins_checksum_func_create_login_store_with_nss_keymanager();
  uint16_t uniffi_logins_checksum_func_create_login_store_with_static_key_manager();
  uint16_t uniffi_logins_checksum_func_create_managed_encdec();
  uint16_t uniffi_logins_checksum_func_create_static_key_manager();
  uint16_t uniffi_logins_checksum_method_encryptordecryptor_decrypt();
  uint16_t uniffi_logins_checksum_method_encryptordecryptor_encrypt();
  uint16_t uniffi_logins_checksum_method_keymanager_get_key();
  uint16_t uniffi_logins_checksum_constructor_loginstore_new();
  uint16_t uniffi_logins_checksum_method_loginstore_add();
  uint16_t uniffi_logins_checksum_method_loginstore_add_many();
  uint16_t uniffi_logins_checksum_method_loginstore_add_many_with_meta();
  uint16_t uniffi_logins_checksum_method_loginstore_add_or_update();
  uint16_t uniffi_logins_checksum_method_loginstore_add_with_meta();
  uint16_t uniffi_logins_checksum_method_loginstore_are_potentially_vulnerable_passwords();
  uint16_t uniffi_logins_checksum_method_loginstore_count();
  uint16_t uniffi_logins_checksum_method_loginstore_count_by_form_action_origin();
  uint16_t uniffi_logins_checksum_method_loginstore_count_by_origin();
  uint16_t uniffi_logins_checksum_method_loginstore_delete();
  uint16_t uniffi_logins_checksum_method_loginstore_delete_many();
  uint16_t uniffi_logins_checksum_method_loginstore_delete_undecryptable_records_for_remote_replacement();
  uint16_t uniffi_logins_checksum_method_loginstore_find_login_to_update();
  uint16_t uniffi_logins_checksum_method_loginstore_get();
  uint16_t uniffi_logins_checksum_method_loginstore_get_by_base_domain();
  uint16_t uniffi_logins_checksum_method_loginstore_get_checkpoint();
  uint16_t uniffi_logins_checksum_method_loginstore_has_logins_by_base_domain();
  uint16_t uniffi_logins_checksum_method_loginstore_is_breach_alert_dismissed();
  uint16_t uniffi_logins_checksum_method_loginstore_is_empty();
  uint16_t uniffi_logins_checksum_method_loginstore_is_potentially_breached();
  uint16_t uniffi_logins_checksum_method_loginstore_is_potentially_vulnerable_password();
  uint16_t uniffi_logins_checksum_method_loginstore_list();
  uint16_t uniffi_logins_checksum_method_loginstore_record_breach();
  uint16_t uniffi_logins_checksum_method_loginstore_record_breach_alert_dismissal();
  uint16_t uniffi_logins_checksum_method_loginstore_record_breach_alert_dismissal_time();
  uint16_t uniffi_logins_checksum_method_loginstore_record_potentially_vulnerable_passwords();
  uint16_t uniffi_logins_checksum_method_loginstore_register_with_sync_manager();
  uint16_t uniffi_logins_checksum_method_loginstore_reset();
  uint16_t uniffi_logins_checksum_method_loginstore_reset_all_breaches();
  uint16_t uniffi_logins_checksum_method_loginstore_run_maintenance();
  uint16_t uniffi_logins_checksum_method_loginstore_set_checkpoint();
  uint16_t uniffi_logins_checksum_method_loginstore_shutdown();
  uint16_t uniffi_logins_checksum_method_loginstore_touch();
  uint16_t uniffi_logins_checksum_method_loginstore_update();
  uint16_t uniffi_logins_checksum_method_loginstore_wipe_local();
  uint16_t uniffi_logins_checksum_constructor_managedencryptordecryptor_new();
  uint16_t uniffi_logins_checksum_constructor_nsskeymanager_new();
  uint16_t uniffi_logins_checksum_method_nsskeymanager_into_dyn_key_manager();
  uint16_t uniffi_logins_checksum_method_primarypasswordauthenticator_get_primary_password();
  uint16_t uniffi_logins_checksum_method_primarypasswordauthenticator_on_authentication_success();
  uint16_t uniffi_logins_checksum_method_primarypasswordauthenticator_on_authentication_failure();
  uint16_t uniffi_logins_checksum_constructor_statickeymanager_new();
  RustBuffer ffi_relevancy_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_relevancy_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_relevancy_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_relevancy_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_relevancy_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_u8(uint64_t);
  void ffi_relevancy_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_i8(uint64_t);
  int8_t ffi_relevancy_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_i8(uint64_t);
  void ffi_relevancy_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_relevancy_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_u16(uint64_t);
  void ffi_relevancy_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_i16(uint64_t);
  int16_t ffi_relevancy_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_i16(uint64_t);
  void ffi_relevancy_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_relevancy_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_u32(uint64_t);
  void ffi_relevancy_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_i32(uint64_t);
  int32_t ffi_relevancy_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_i32(uint64_t);
  void ffi_relevancy_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_relevancy_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_u64(uint64_t);
  void ffi_relevancy_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_i64(uint64_t);
  int64_t ffi_relevancy_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_i64(uint64_t);
  void ffi_relevancy_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_f32(uint64_t);
  float ffi_relevancy_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_f32(uint64_t);
  void ffi_relevancy_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_f64(uint64_t);
  double ffi_relevancy_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_f64(uint64_t);
  void ffi_relevancy_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_relevancy_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_rust_buffer(uint64_t);
  void ffi_relevancy_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_void(uint64_t);
  void ffi_relevancy_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_void(uint64_t);
  uint64_t uniffi_relevancy_fn_clone_relevancystore(uint64_t, RustCallStatus*);
  void uniffi_relevancy_fn_free_relevancystore(uint64_t, RustCallStatus*);
  double uniffi_relevancy_fn_func_score(RustBuffer, RustBuffer, RustCallStatus*);
  uint64_t uniffi_relevancy_fn_constructor_relevancystore_new(RustBuffer, uint64_t, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_bandit_init(uint64_t, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_relevancy_fn_method_relevancystore_bandit_select(uint64_t, RustBuffer, RustBuffer, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_bandit_update(uint64_t, RustBuffer, RustBuffer, int8_t, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_close(uint64_t, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_ensure_interest_data_populated(uint64_t, RustCallStatus*);
  RustBuffer uniffi_relevancy_fn_method_relevancystore_get_bandit_data(uint64_t, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_relevancy_fn_method_relevancystore_ingest(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_interrupt(uint64_t, RustCallStatus*);
  RustBuffer uniffi_relevancy_fn_method_relevancystore_user_interest_vector(uint64_t, RustCallStatus*);
  uint32_t ffi_relevancy_uniffi_contract_version();
  uint16_t uniffi_relevancy_checksum_func_score();
  uint16_t uniffi_relevancy_checksum_constructor_relevancystore_new();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_bandit_init();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_bandit_select();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_bandit_update();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_close();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_ensure_interest_data_populated();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_get_bandit_data();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_ingest();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_interrupt();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_user_interest_vector();
  RustBuffer ffi_remote_settings_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_remote_settings_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_remote_settings_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_remote_settings_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_remote_settings_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_u8(uint64_t);
  void ffi_remote_settings_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_i8(uint64_t);
  int8_t ffi_remote_settings_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_i8(uint64_t);
  void ffi_remote_settings_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_remote_settings_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_u16(uint64_t);
  void ffi_remote_settings_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_i16(uint64_t);
  int16_t ffi_remote_settings_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_i16(uint64_t);
  void ffi_remote_settings_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_remote_settings_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_u32(uint64_t);
  void ffi_remote_settings_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_i32(uint64_t);
  int32_t ffi_remote_settings_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_i32(uint64_t);
  void ffi_remote_settings_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_remote_settings_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_u64(uint64_t);
  void ffi_remote_settings_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_i64(uint64_t);
  int64_t ffi_remote_settings_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_i64(uint64_t);
  void ffi_remote_settings_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_f32(uint64_t);
  float ffi_remote_settings_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_f32(uint64_t);
  void ffi_remote_settings_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_f64(uint64_t);
  double ffi_remote_settings_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_f64(uint64_t);
  void ffi_remote_settings_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_remote_settings_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_rust_buffer(uint64_t);
  void ffi_remote_settings_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_void(uint64_t);
  void ffi_remote_settings_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_void(uint64_t);
  uint64_t uniffi_remote_settings_fn_clone_remotesettings(uint64_t, RustCallStatus*);
  void uniffi_remote_settings_fn_free_remotesettings(uint64_t, RustCallStatus*);
  uint64_t uniffi_remote_settings_fn_clone_remotesettingsclient(uint64_t, RustCallStatus*);
  void uniffi_remote_settings_fn_free_remotesettingsclient(uint64_t, RustCallStatus*);
  uint64_t uniffi_remote_settings_fn_clone_remotesettingsservice(uint64_t, RustCallStatus*);
  void uniffi_remote_settings_fn_free_remotesettingsservice(uint64_t, RustCallStatus*);
  uint64_t uniffi_remote_settings_fn_constructor_remotesettings_new(RustBuffer, RustCallStatus*);
  void uniffi_remote_settings_fn_method_remotesettings_download_attachment_to_path(uint64_t, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettings_get_records(uint64_t, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettings_get_records_since(uint64_t, uint64_t, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsclient_collection_name(uint64_t, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsclient_get_attachment(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsclient_get_records(uint64_t, int8_t, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsclient_get_records_map(uint64_t, int8_t, RustCallStatus*);
  void uniffi_remote_settings_fn_method_remotesettingsclient_shutdown(uint64_t, RustCallStatus*);
  void uniffi_remote_settings_fn_method_remotesettingsclient_sync(uint64_t, RustCallStatus*);
  uint64_t uniffi_remote_settings_fn_constructor_remotesettingsservice_new(RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsservice_client_url(uint64_t, RustCallStatus*);
  uint64_t uniffi_remote_settings_fn_method_remotesettingsservice_make_client(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsservice_sync(uint64_t, RustCallStatus*);
  void uniffi_remote_settings_fn_method_remotesettingsservice_update_config(uint64_t, RustBuffer, RustCallStatus*);
  uint32_t ffi_remote_settings_uniffi_contract_version();
  uint16_t uniffi_remote_settings_checksum_constructor_remotesettings_new();
  uint16_t uniffi_remote_settings_checksum_method_remotesettings_download_attachment_to_path();
  uint16_t uniffi_remote_settings_checksum_method_remotesettings_get_records();
  uint16_t uniffi_remote_settings_checksum_method_remotesettings_get_records_since();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_collection_name();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_get_attachment();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_get_records();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_get_records_map();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_shutdown();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_sync();
  uint16_t uniffi_remote_settings_checksum_constructor_remotesettingsservice_new();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsservice_client_url();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsservice_make_client();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsservice_sync();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsservice_update_config();
  RustBuffer ffi_search_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_search_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_search_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_search_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_search_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_search_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_u8(uint64_t);
  void ffi_search_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_i8(uint64_t);
  int8_t ffi_search_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_i8(uint64_t);
  void ffi_search_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_search_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_u16(uint64_t);
  void ffi_search_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_i16(uint64_t);
  int16_t ffi_search_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_i16(uint64_t);
  void ffi_search_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_search_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_u32(uint64_t);
  void ffi_search_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_i32(uint64_t);
  int32_t ffi_search_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_i32(uint64_t);
  void ffi_search_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_search_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_u64(uint64_t);
  void ffi_search_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_i64(uint64_t);
  int64_t ffi_search_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_i64(uint64_t);
  void ffi_search_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_f32(uint64_t);
  float ffi_search_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_f32(uint64_t);
  void ffi_search_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_f64(uint64_t);
  double ffi_search_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_f64(uint64_t);
  void ffi_search_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_search_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_rust_buffer(uint64_t);
  void ffi_search_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_void(uint64_t);
  void ffi_search_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_void(uint64_t);
  uint64_t uniffi_search_fn_clone_searchengineselector(uint64_t, RustCallStatus*);
  void uniffi_search_fn_free_searchengineselector(uint64_t, RustCallStatus*);
  uint64_t uniffi_search_fn_constructor_searchengineselector_new(RustCallStatus*);
  void uniffi_search_fn_method_searchengineselector_clear_search_config(uint64_t, RustCallStatus*);
  RustBuffer uniffi_search_fn_method_searchengineselector_filter_engine_configuration(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_search_fn_method_searchengineselector_set_config_overrides(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_search_fn_method_searchengineselector_set_search_config(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_search_fn_method_searchengineselector_use_remote_settings_server(uint64_t, uint64_t, int8_t, RustCallStatus*);
  uint32_t ffi_search_uniffi_contract_version();
  uint16_t uniffi_search_checksum_constructor_searchengineselector_new();
  uint16_t uniffi_search_checksum_method_searchengineselector_clear_search_config();
  uint16_t uniffi_search_checksum_method_searchengineselector_filter_engine_configuration();
  uint16_t uniffi_search_checksum_method_searchengineselector_set_config_overrides();
  uint16_t uniffi_search_checksum_method_searchengineselector_set_search_config();
  uint16_t uniffi_search_checksum_method_searchengineselector_use_remote_settings_server();
  RustBuffer ffi_suggest_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_suggest_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_suggest_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_suggest_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_suggest_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_u8(uint64_t);
  void ffi_suggest_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_i8(uint64_t);
  int8_t ffi_suggest_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_i8(uint64_t);
  void ffi_suggest_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_suggest_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_u16(uint64_t);
  void ffi_suggest_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_i16(uint64_t);
  int16_t ffi_suggest_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_i16(uint64_t);
  void ffi_suggest_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_suggest_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_u32(uint64_t);
  void ffi_suggest_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_i32(uint64_t);
  int32_t ffi_suggest_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_i32(uint64_t);
  void ffi_suggest_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_suggest_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_u64(uint64_t);
  void ffi_suggest_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_i64(uint64_t);
  int64_t ffi_suggest_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_i64(uint64_t);
  void ffi_suggest_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_f32(uint64_t);
  float ffi_suggest_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_f32(uint64_t);
  void ffi_suggest_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_f64(uint64_t);
  double ffi_suggest_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_f64(uint64_t);
  void ffi_suggest_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_suggest_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_rust_buffer(uint64_t);
  void ffi_suggest_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_void(uint64_t);
  void ffi_suggest_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_void(uint64_t);
  uint64_t uniffi_suggest_fn_clone_suggeststore(uint64_t, RustCallStatus*);
  void uniffi_suggest_fn_free_suggeststore(uint64_t, RustCallStatus*);
  uint64_t uniffi_suggest_fn_clone_suggeststorebuilder(uint64_t, RustCallStatus*);
  void uniffi_suggest_fn_free_suggeststorebuilder(uint64_t, RustCallStatus*);
  int8_t uniffi_suggest_fn_func_raw_suggestion_url_matches(RustBuffer, RustBuffer, RustCallStatus*);
  uint64_t uniffi_suggest_fn_constructor_suggeststore_new(RustBuffer, uint64_t, RustCallStatus*);
  int8_t uniffi_suggest_fn_method_suggeststore_any_dismissed_suggestions(uint64_t, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_clear(uint64_t, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_clear_dismissed_suggestions(uint64_t, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_dismiss_by_key(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_dismiss_by_suggestion(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_dismiss_suggestion(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_fetch_geoname_alternates(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_fetch_geonames(uint64_t, RustBuffer, int8_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_fetch_global_config(uint64_t, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_fetch_provider_config(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_ingest(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_interrupt(uint64_t, RustBuffer, RustCallStatus*);
  int8_t uniffi_suggest_fn_method_suggeststore_is_dismissed_by_key(uint64_t, RustBuffer, RustCallStatus*);
  int8_t uniffi_suggest_fn_method_suggeststore_is_dismissed_by_suggestion(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_query(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_query_with_metrics(uint64_t, RustBuffer, RustCallStatus*);
  uint64_t uniffi_suggest_fn_constructor_suggeststorebuilder_new(RustCallStatus*);
  uint64_t uniffi_suggest_fn_method_suggeststorebuilder_build(uint64_t, RustCallStatus*);
  uint64_t uniffi_suggest_fn_method_suggeststorebuilder_cache_path(uint64_t, RustBuffer, RustCallStatus*);
  uint64_t uniffi_suggest_fn_method_suggeststorebuilder_data_path(uint64_t, RustBuffer, RustCallStatus*);
  uint64_t uniffi_suggest_fn_method_suggeststorebuilder_load_extension(uint64_t, RustBuffer, RustBuffer, RustCallStatus*);
  uint64_t uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_bucket_name(uint64_t, RustBuffer, RustCallStatus*);
  uint64_t uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_server(uint64_t, RustBuffer, RustCallStatus*);
  uint64_t uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_service(uint64_t, uint64_t, RustCallStatus*);
  uint32_t ffi_suggest_uniffi_contract_version();
  uint16_t uniffi_suggest_checksum_func_raw_suggestion_url_matches();
  uint16_t uniffi_suggest_checksum_constructor_suggeststore_new();
  uint16_t uniffi_suggest_checksum_method_suggeststore_any_dismissed_suggestions();
  uint16_t uniffi_suggest_checksum_method_suggeststore_clear();
  uint16_t uniffi_suggest_checksum_method_suggeststore_clear_dismissed_suggestions();
  uint16_t uniffi_suggest_checksum_method_suggeststore_dismiss_by_key();
  uint16_t uniffi_suggest_checksum_method_suggeststore_dismiss_by_suggestion();
  uint16_t uniffi_suggest_checksum_method_suggeststore_dismiss_suggestion();
  uint16_t uniffi_suggest_checksum_method_suggeststore_fetch_geoname_alternates();
  uint16_t uniffi_suggest_checksum_method_suggeststore_fetch_geonames();
  uint16_t uniffi_suggest_checksum_method_suggeststore_fetch_global_config();
  uint16_t uniffi_suggest_checksum_method_suggeststore_fetch_provider_config();
  uint16_t uniffi_suggest_checksum_method_suggeststore_ingest();
  uint16_t uniffi_suggest_checksum_method_suggeststore_interrupt();
  uint16_t uniffi_suggest_checksum_method_suggeststore_is_dismissed_by_key();
  uint16_t uniffi_suggest_checksum_method_suggeststore_is_dismissed_by_suggestion();
  uint16_t uniffi_suggest_checksum_method_suggeststore_query();
  uint16_t uniffi_suggest_checksum_method_suggeststore_query_with_metrics();
  uint16_t uniffi_suggest_checksum_constructor_suggeststorebuilder_new();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_build();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_cache_path();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_data_path();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_load_extension();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_remote_settings_bucket_name();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_remote_settings_server();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_remote_settings_service();
  RustBuffer ffi_sync15_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_sync15_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_sync15_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_sync15_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_sync15_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_u8(uint64_t);
  void ffi_sync15_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_i8(uint64_t);
  int8_t ffi_sync15_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_i8(uint64_t);
  void ffi_sync15_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_sync15_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_u16(uint64_t);
  void ffi_sync15_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_i16(uint64_t);
  int16_t ffi_sync15_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_i16(uint64_t);
  void ffi_sync15_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_sync15_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_u32(uint64_t);
  void ffi_sync15_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_i32(uint64_t);
  int32_t ffi_sync15_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_i32(uint64_t);
  void ffi_sync15_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_sync15_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_u64(uint64_t);
  void ffi_sync15_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_i64(uint64_t);
  int64_t ffi_sync15_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_i64(uint64_t);
  void ffi_sync15_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_f32(uint64_t);
  float ffi_sync15_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_f32(uint64_t);
  void ffi_sync15_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_f64(uint64_t);
  double ffi_sync15_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_f64(uint64_t);
  void ffi_sync15_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_sync15_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_rust_buffer(uint64_t);
  void ffi_sync15_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_void(uint64_t);
  void ffi_sync15_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_void(uint64_t);
  uint32_t ffi_sync15_uniffi_contract_version();
  RustBuffer ffi_tabs_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_tabs_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_tabs_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_tabs_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_tabs_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_u8(uint64_t);
  void ffi_tabs_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_i8(uint64_t);
  int8_t ffi_tabs_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_i8(uint64_t);
  void ffi_tabs_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_tabs_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_u16(uint64_t);
  void ffi_tabs_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_i16(uint64_t);
  int16_t ffi_tabs_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_i16(uint64_t);
  void ffi_tabs_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_tabs_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_u32(uint64_t);
  void ffi_tabs_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_i32(uint64_t);
  int32_t ffi_tabs_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_i32(uint64_t);
  void ffi_tabs_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_tabs_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_u64(uint64_t);
  void ffi_tabs_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_i64(uint64_t);
  int64_t ffi_tabs_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_i64(uint64_t);
  void ffi_tabs_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_f32(uint64_t);
  float ffi_tabs_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_f32(uint64_t);
  void ffi_tabs_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_f64(uint64_t);
  double ffi_tabs_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_f64(uint64_t);
  void ffi_tabs_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_tabs_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_rust_buffer(uint64_t);
  void ffi_tabs_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_void(uint64_t);
  void ffi_tabs_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_void(uint64_t);
  uint64_t uniffi_tabs_fn_clone_remotecommandstore(uint64_t, RustCallStatus*);
  void uniffi_tabs_fn_free_remotecommandstore(uint64_t, RustCallStatus*);
  uint64_t uniffi_tabs_fn_clone_tabsbridgedengine(uint64_t, RustCallStatus*);
  void uniffi_tabs_fn_free_tabsbridgedengine(uint64_t, RustCallStatus*);
  uint64_t uniffi_tabs_fn_clone_tabsstore(uint64_t, RustCallStatus*);
  void uniffi_tabs_fn_free_tabsstore(uint64_t, RustCallStatus*);
  int8_t uniffi_tabs_fn_method_remotecommandstore_add_remote_command(uint64_t, RustBuffer, RustBuffer, RustCallStatus*);
  int8_t uniffi_tabs_fn_method_remotecommandstore_add_remote_command_at(uint64_t, RustBuffer, RustBuffer, int64_t, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_remotecommandstore_get_unsent_commands(uint64_t, RustCallStatus*);
  int8_t uniffi_tabs_fn_method_remotecommandstore_remove_remote_command(uint64_t, RustBuffer, RustBuffer, RustCallStatus*);
  int8_t uniffi_tabs_fn_method_remotecommandstore_set_pending_command_sent(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsbridgedengine_apply(uint64_t, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsbridgedengine_ensure_current_sync_id(uint64_t, RustBuffer, RustCallStatus*);
  int64_t uniffi_tabs_fn_method_tabsbridgedengine_last_sync(uint64_t, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_prepare_for_sync(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_reset(uint64_t, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsbridgedengine_reset_sync_id(uint64_t, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_set_last_sync(uint64_t, int64_t, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_set_uploaded(uint64_t, int64_t, RustBuffer, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_store_incoming(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_sync_finished(uint64_t, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsbridgedengine_sync_id(uint64_t, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_sync_started(uint64_t, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_wipe(uint64_t, RustCallStatus*);
  uint64_t uniffi_tabs_fn_constructor_tabsstore_new(RustBuffer, RustCallStatus*);
  uint64_t uniffi_tabs_fn_method_tabsstore_bridged_engine(uint64_t, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsstore_close_connection(uint64_t, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsstore_get_all(uint64_t, RustCallStatus*);
  uint64_t uniffi_tabs_fn_method_tabsstore_new_remote_command_store(uint64_t, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsstore_register_with_sync_manager(uint64_t, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsstore_set_local_tabs(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsstore_set_local_tabs_info(uint64_t, RustBuffer, RustCallStatus*);
  uint32_t ffi_tabs_uniffi_contract_version();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_add_remote_command();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_add_remote_command_at();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_get_unsent_commands();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_remove_remote_command();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_set_pending_command_sent();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_apply();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_ensure_current_sync_id();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_last_sync();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_prepare_for_sync();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_reset();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_reset_sync_id();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_set_last_sync();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_set_uploaded();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_store_incoming();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_sync_finished();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_sync_id();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_sync_started();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_wipe();
  uint16_t uniffi_tabs_checksum_constructor_tabsstore_new();
  uint16_t uniffi_tabs_checksum_method_tabsstore_bridged_engine();
  uint16_t uniffi_tabs_checksum_method_tabsstore_close_connection();
  uint16_t uniffi_tabs_checksum_method_tabsstore_get_all();
  uint16_t uniffi_tabs_checksum_method_tabsstore_new_remote_command_store();
  uint16_t uniffi_tabs_checksum_method_tabsstore_register_with_sync_manager();
  uint16_t uniffi_tabs_checksum_method_tabsstore_set_local_tabs();
  uint16_t uniffi_tabs_checksum_method_tabsstore_set_local_tabs_info();
  RustBuffer ffi_tracing_support_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_tracing_support_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_tracing_support_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_tracing_support_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_tracing_support_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tracing_support_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_tracing_support_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_tracing_support_rust_future_free_u8(uint64_t);
  void ffi_tracing_support_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tracing_support_rust_future_cancel_i8(uint64_t);
  int8_t ffi_tracing_support_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_tracing_support_rust_future_free_i8(uint64_t);
  void ffi_tracing_support_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tracing_support_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_tracing_support_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_tracing_support_rust_future_free_u16(uint64_t);
  void ffi_tracing_support_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tracing_support_rust_future_cancel_i16(uint64_t);
  int16_t ffi_tracing_support_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_tracing_support_rust_future_free_i16(uint64_t);
  void ffi_tracing_support_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tracing_support_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_tracing_support_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_tracing_support_rust_future_free_u32(uint64_t);
  void ffi_tracing_support_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tracing_support_rust_future_cancel_i32(uint64_t);
  int32_t ffi_tracing_support_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_tracing_support_rust_future_free_i32(uint64_t);
  void ffi_tracing_support_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tracing_support_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_tracing_support_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_tracing_support_rust_future_free_u64(uint64_t);
  void ffi_tracing_support_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tracing_support_rust_future_cancel_i64(uint64_t);
  int64_t ffi_tracing_support_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_tracing_support_rust_future_free_i64(uint64_t);
  void ffi_tracing_support_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tracing_support_rust_future_cancel_f32(uint64_t);
  float ffi_tracing_support_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_tracing_support_rust_future_free_f32(uint64_t);
  void ffi_tracing_support_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tracing_support_rust_future_cancel_f64(uint64_t);
  double ffi_tracing_support_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_tracing_support_rust_future_free_f64(uint64_t);
  void ffi_tracing_support_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tracing_support_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_tracing_support_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_tracing_support_rust_future_free_rust_buffer(uint64_t);
  void ffi_tracing_support_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tracing_support_rust_future_cancel_void(uint64_t);
  void ffi_tracing_support_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_tracing_support_rust_future_free_void(uint64_t);
  typedef void (*CallbackInterfaceTracingEventSinkMethod0)(uint64_t, RustBuffer, void*, RustCallStatus*);
  typedef uint64_t (*CallbackInterfaceCloneTracing_EventSink)(uint64_t);
  typedef void (*CallbackInterfaceFreeTracing_EventSink)(uint64_t);
  struct VTableCallbackInterfaceTracingEventSink {
    CallbackInterfaceFreeTracing_EventSink uniffi_free;
    CallbackInterfaceCloneTracing_EventSink uniffi_clone;
    CallbackInterfaceTracingEventSinkMethod0 on_event;
  };
  void uniffi_tracing_support_fn_init_callback_vtable_eventsink(VTableCallbackInterfaceTracingEventSink*);
  uint32_t uniffi_tracing_support_fn_func_register_event_sink(RustBuffer, uint64_t, RustCallStatus*);
  void uniffi_tracing_support_fn_func_unregister_event_sink(uint32_t, RustCallStatus*);
  uint32_t ffi_tracing_support_uniffi_contract_version();
  uint16_t uniffi_tracing_support_checksum_func_register_event_sink();
  uint16_t uniffi_tracing_support_checksum_func_unregister_event_sink();
  RustBuffer ffi_viaduct_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_viaduct_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_viaduct_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_viaduct_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_viaduct_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_viaduct_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_viaduct_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_viaduct_rust_future_free_u8(uint64_t);
  void ffi_viaduct_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_viaduct_rust_future_cancel_i8(uint64_t);
  int8_t ffi_viaduct_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_viaduct_rust_future_free_i8(uint64_t);
  void ffi_viaduct_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_viaduct_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_viaduct_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_viaduct_rust_future_free_u16(uint64_t);
  void ffi_viaduct_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_viaduct_rust_future_cancel_i16(uint64_t);
  int16_t ffi_viaduct_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_viaduct_rust_future_free_i16(uint64_t);
  void ffi_viaduct_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_viaduct_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_viaduct_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_viaduct_rust_future_free_u32(uint64_t);
  void ffi_viaduct_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_viaduct_rust_future_cancel_i32(uint64_t);
  int32_t ffi_viaduct_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_viaduct_rust_future_free_i32(uint64_t);
  void ffi_viaduct_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_viaduct_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_viaduct_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_viaduct_rust_future_free_u64(uint64_t);
  void ffi_viaduct_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_viaduct_rust_future_cancel_i64(uint64_t);
  int64_t ffi_viaduct_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_viaduct_rust_future_free_i64(uint64_t);
  void ffi_viaduct_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_viaduct_rust_future_cancel_f32(uint64_t);
  float ffi_viaduct_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_viaduct_rust_future_free_f32(uint64_t);
  void ffi_viaduct_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_viaduct_rust_future_cancel_f64(uint64_t);
  double ffi_viaduct_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_viaduct_rust_future_free_f64(uint64_t);
  void ffi_viaduct_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_viaduct_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_viaduct_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_viaduct_rust_future_free_rust_buffer(uint64_t);
  void ffi_viaduct_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_viaduct_rust_future_cancel_void(uint64_t);
  void ffi_viaduct_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_viaduct_rust_future_free_void(uint64_t);
  uint64_t uniffi_viaduct_fn_clone_backend(uint64_t, RustCallStatus*);
  void uniffi_viaduct_fn_free_backend(uint64_t, RustCallStatus*);
  typedef void (*CallbackInterfaceViaductBackendMethod0)(uint64_t, RustBuffer, RustBuffer, ForeignFutureCompleterust_buffer, uint64_t, ForeignFutureDroppedCallbackStruct*);
  typedef uint64_t (*CallbackInterfaceCloneViaduct_Backend)(uint64_t);
  typedef void (*CallbackInterfaceFreeViaduct_Backend)(uint64_t);
  struct VTableCallbackInterfaceViaductBackend {
    CallbackInterfaceFreeViaduct_Backend uniffi_free;
    CallbackInterfaceCloneViaduct_Backend uniffi_clone;
    CallbackInterfaceViaductBackendMethod0 send_request;
  };
  void uniffi_viaduct_fn_init_callback_vtable_backend(VTableCallbackInterfaceViaductBackend*);
  void uniffi_viaduct_fn_func_allow_android_emulator_loopback(RustCallStatus*);
  void uniffi_viaduct_fn_func_init_backend(uint64_t, RustCallStatus*);
  void uniffi_viaduct_fn_func_set_global_default_user_agent(RustBuffer, RustCallStatus*);
  uint64_t uniffi_viaduct_fn_method_backend_send_request(uint64_t, RustBuffer, RustBuffer);
  uint32_t ffi_viaduct_uniffi_contract_version();
  uint16_t uniffi_viaduct_checksum_func_allow_android_emulator_loopback();
  uint16_t uniffi_viaduct_checksum_func_init_backend();
  uint16_t uniffi_viaduct_checksum_func_set_global_default_user_agent();
  uint16_t uniffi_viaduct_checksum_method_backend_send_request();
  RustBuffer ffi_webext_storage_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_webext_storage_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_webext_storage_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_webext_storage_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_webext_storage_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_u8(uint64_t);
  void ffi_webext_storage_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_i8(uint64_t);
  int8_t ffi_webext_storage_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_i8(uint64_t);
  void ffi_webext_storage_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_webext_storage_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_u16(uint64_t);
  void ffi_webext_storage_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_i16(uint64_t);
  int16_t ffi_webext_storage_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_i16(uint64_t);
  void ffi_webext_storage_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_webext_storage_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_u32(uint64_t);
  void ffi_webext_storage_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_i32(uint64_t);
  int32_t ffi_webext_storage_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_i32(uint64_t);
  void ffi_webext_storage_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_webext_storage_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_u64(uint64_t);
  void ffi_webext_storage_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_i64(uint64_t);
  int64_t ffi_webext_storage_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_i64(uint64_t);
  void ffi_webext_storage_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_f32(uint64_t);
  float ffi_webext_storage_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_f32(uint64_t);
  void ffi_webext_storage_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_f64(uint64_t);
  double ffi_webext_storage_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_f64(uint64_t);
  void ffi_webext_storage_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_webext_storage_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_rust_buffer(uint64_t);
  void ffi_webext_storage_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_void(uint64_t);
  void ffi_webext_storage_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_void(uint64_t);
  uint64_t uniffi_webext_storage_fn_clone_webextstoragebridgedengine(uint64_t, RustCallStatus*);
  void uniffi_webext_storage_fn_free_webextstoragebridgedengine(uint64_t, RustCallStatus*);
  uint64_t uniffi_webext_storage_fn_clone_webextstoragestore(uint64_t, RustCallStatus*);
  void uniffi_webext_storage_fn_free_webextstoragestore(uint64_t, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragebridgedengine_apply(uint64_t, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragebridgedengine_ensure_current_sync_id(uint64_t, RustBuffer, RustCallStatus*);
  int64_t uniffi_webext_storage_fn_method_webextstoragebridgedengine_last_sync(uint64_t, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_prepare_for_sync(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset(uint64_t, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset_sync_id(uint64_t, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_last_sync(uint64_t, int64_t, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_uploaded(uint64_t, int64_t, RustBuffer, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_store_incoming(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_finished(uint64_t, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_id(uint64_t, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_started(uint64_t, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_wipe(uint64_t, RustCallStatus*);
  uint64_t uniffi_webext_storage_fn_constructor_webextstoragestore_new(RustBuffer, RustCallStatus*);
  uint64_t uniffi_webext_storage_fn_method_webextstoragestore_bridged_engine(uint64_t, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_clear(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragestore_close(uint64_t, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_get(uint64_t, RustBuffer, RustBuffer, RustCallStatus*);
  uint64_t uniffi_webext_storage_fn_method_webextstoragestore_get_bytes_in_use(uint64_t, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_get_keys(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_get_synced_changes(uint64_t, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_remove(uint64_t, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_set(uint64_t, RustBuffer, RustBuffer, RustCallStatus*);
  uint32_t ffi_webext_storage_uniffi_contract_version();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_apply();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_ensure_current_sync_id();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_last_sync();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_prepare_for_sync();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_reset();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_reset_sync_id();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_set_last_sync();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_set_uploaded();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_store_incoming();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_sync_finished();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_sync_id();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_sync_started();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_wipe();
  uint16_t uniffi_webext_storage_checksum_constructor_webextstoragestore_new();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_bridged_engine();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_clear();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_close();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_get();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_get_bytes_in_use();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_get_keys();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_get_synced_changes();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_remove();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_set();

#ifdef MOZ_UNIFFI_FIXTURES
  RustBuffer ffi_uniffi_bindings_tests_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_bindings_tests_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_bindings_tests_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_uniffi_bindings_tests_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_u8(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_i8(uint64_t);
  int8_t ffi_uniffi_bindings_tests_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_i8(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_uniffi_bindings_tests_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_u16(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_i16(uint64_t);
  int16_t ffi_uniffi_bindings_tests_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_i16(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_uniffi_bindings_tests_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_u32(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_i32(uint64_t);
  int32_t ffi_uniffi_bindings_tests_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_i32(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_uniffi_bindings_tests_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_u64(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_i64(uint64_t);
  int64_t ffi_uniffi_bindings_tests_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_i64(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_f32(uint64_t);
  float ffi_uniffi_bindings_tests_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_f32(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_f64(uint64_t);
  double ffi_uniffi_bindings_tests_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_f64(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_rust_buffer(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_void(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_clone_asyncinterface(uint64_t, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_free_asyncinterface(uint64_t, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_clone_asynctesttraitinterface(uint64_t, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_free_asynctesttraitinterface(uint64_t, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_clone_complexmethods(uint64_t, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_free_complexmethods(uint64_t, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_clone_testinterface(uint64_t, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_free_testinterface(uint64_t, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_clone_testtraitinterface(uint64_t, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_free_testtraitinterface(uint64_t, RustCallStatus*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterfaceMethod0)(uint64_t, ForeignFutureCompletevoid, uint64_t, ForeignFutureDroppedCallbackStruct*);
  struct ForeignFutureResultU32 {
    uint32_t return_value;
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompleteu32)(uint64_t, ForeignFutureResultU32);
  typedef void (*CallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterfaceMethod1)(uint64_t, ForeignFutureCompleteu32, uint64_t, ForeignFutureDroppedCallbackStruct*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterfaceMethod2)(uint64_t, uint32_t, ForeignFutureCompletevoid, uint64_t, ForeignFutureDroppedCallbackStruct*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterfaceMethod3)(uint64_t, RustBuffer, ForeignFutureCompleterust_buffer, uint64_t, ForeignFutureDroppedCallbackStruct*);
  typedef uint64_t (*CallbackInterfaceCloneUniffiBindingsTests_AsyncTestTraitInterface)(uint64_t);
  typedef void (*CallbackInterfaceFreeUniffiBindingsTests_AsyncTestTraitInterface)(uint64_t);
  struct VTableCallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterface {
    CallbackInterfaceFreeUniffiBindingsTests_AsyncTestTraitInterface uniffi_free;
    CallbackInterfaceCloneUniffiBindingsTests_AsyncTestTraitInterface uniffi_clone;
    CallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterfaceMethod0 noop;
    CallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterfaceMethod1 get_value;
    CallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterfaceMethod2 set_value;
    CallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterfaceMethod3 throw_if_equal;
  };
  void uniffi_uniffi_bindings_tests_fn_init_callback_vtable_asynctesttraitinterface(VTableCallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterface*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestTraitInterfaceMethod0)(uint64_t, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestTraitInterfaceMethod1)(uint64_t, uint32_t*, RustCallStatus*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestTraitInterfaceMethod2)(uint64_t, uint32_t, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestTraitInterfaceMethod3)(uint64_t, RustBuffer, RustBuffer*, RustCallStatus*);
  typedef uint64_t (*CallbackInterfaceCloneUniffiBindingsTests_TestTraitInterface)(uint64_t);
  typedef void (*CallbackInterfaceFreeUniffiBindingsTests_TestTraitInterface)(uint64_t);
  struct VTableCallbackInterfaceUniffiBindingsTestsTestTraitInterface {
    CallbackInterfaceFreeUniffiBindingsTests_TestTraitInterface uniffi_free;
    CallbackInterfaceCloneUniffiBindingsTests_TestTraitInterface uniffi_clone;
    CallbackInterfaceUniffiBindingsTestsTestTraitInterfaceMethod0 noop;
    CallbackInterfaceUniffiBindingsTestsTestTraitInterfaceMethod1 get_value;
    CallbackInterfaceUniffiBindingsTestsTestTraitInterfaceMethod2 set_value;
    CallbackInterfaceUniffiBindingsTestsTestTraitInterfaceMethod3 throw_if_equal;
  };
  void uniffi_uniffi_bindings_tests_fn_init_callback_vtable_testtraitinterface(VTableCallbackInterfaceUniffiBindingsTestsTestTraitInterface*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterfaceMethod0)(uint64_t, ForeignFutureCompletevoid, uint64_t, ForeignFutureDroppedCallbackStruct*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterfaceMethod1)(uint64_t, ForeignFutureCompleteu32, uint64_t, ForeignFutureDroppedCallbackStruct*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterfaceMethod2)(uint64_t, uint32_t, ForeignFutureCompletevoid, uint64_t, ForeignFutureDroppedCallbackStruct*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterfaceMethod3)(uint64_t, RustBuffer, ForeignFutureCompleterust_buffer, uint64_t, ForeignFutureDroppedCallbackStruct*);
  typedef uint64_t (*CallbackInterfaceCloneUniffiBindingsTests_TestAsyncCallbackInterface)(uint64_t);
  typedef void (*CallbackInterfaceFreeUniffiBindingsTests_TestAsyncCallbackInterface)(uint64_t);
  struct VTableCallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterface {
    CallbackInterfaceFreeUniffiBindingsTests_TestAsyncCallbackInterface uniffi_free;
    CallbackInterfaceCloneUniffiBindingsTests_TestAsyncCallbackInterface uniffi_clone;
    CallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterfaceMethod0 noop;
    CallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterfaceMethod1 get_value;
    CallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterfaceMethod2 set_value;
    CallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterfaceMethod3 throw_if_equal;
  };
  void uniffi_uniffi_bindings_tests_fn_init_callback_vtable_testasynccallbackinterface(VTableCallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterface*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestCallbackInterfaceMethod0)(uint64_t, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestCallbackInterfaceMethod1)(uint64_t, uint32_t*, RustCallStatus*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestCallbackInterfaceMethod2)(uint64_t, uint32_t, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestCallbackInterfaceMethod3)(uint64_t, RustBuffer, RustBuffer*, RustCallStatus*);
  typedef uint64_t (*CallbackInterfaceCloneUniffiBindingsTests_TestCallbackInterface)(uint64_t);
  typedef void (*CallbackInterfaceFreeUniffiBindingsTests_TestCallbackInterface)(uint64_t);
  struct VTableCallbackInterfaceUniffiBindingsTestsTestCallbackInterface {
    CallbackInterfaceFreeUniffiBindingsTests_TestCallbackInterface uniffi_free;
    CallbackInterfaceCloneUniffiBindingsTests_TestCallbackInterface uniffi_clone;
    CallbackInterfaceUniffiBindingsTestsTestCallbackInterfaceMethod0 noop;
    CallbackInterfaceUniffiBindingsTestsTestCallbackInterfaceMethod1 get_value;
    CallbackInterfaceUniffiBindingsTestsTestCallbackInterfaceMethod2 set_value;
    CallbackInterfaceUniffiBindingsTestsTestCallbackInterfaceMethod3 throw_if_equal;
  };
  void uniffi_uniffi_bindings_tests_fn_init_callback_vtable_testcallbackinterface(VTableCallbackInterfaceUniffiBindingsTestsTestCallbackInterface*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_f32(float);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_f64(double);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i16(int16_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i32(int32_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i64(int64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i8(int8_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_map(RustBuffer);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_obj(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_string(RustBuffer);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u16(uint16_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u32(uint32_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u64(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u8(uint8_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_vec(RustBuffer);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_throw_error();
  uint64_t uniffi_uniffi_bindings_tests_fn_func_clone_interface(uint64_t, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_create_async_test_trait_interface(uint32_t, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_create_test_trait_interface(uint32_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_func_with_default(RustBuffer, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_func_with_error(uint32_t, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_func_with_flat_error(uint32_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_func_with_multi_word_arg(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_get_custom_types_demo(RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_invoke_async_test_trait_interface_get_value(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_invoke_async_test_trait_interface_noop(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_invoke_async_test_trait_interface_set_value(uint64_t, uint32_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_invoke_async_test_trait_interface_throw_if_equal(uint64_t, RustBuffer);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_invoke_test_async_callback_interface_get_value(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_invoke_test_async_callback_interface_noop(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_invoke_test_async_callback_interface_set_value(uint64_t, uint32_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_invoke_test_async_callback_interface_throw_if_equal(uint64_t, RustBuffer);
  uint32_t uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_get_value(uint64_t, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_noop(uint64_t, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_set_value(uint64_t, uint32_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_throw_if_equal(uint64_t, RustBuffer, RustCallStatus*);
  uint32_t uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_get_value(uint64_t, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_noop(uint64_t, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_set_value(uint64_t, uint32_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_throw_if_equal(uint64_t, RustBuffer, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_async_test_trait_interface(uint64_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_async_test_trait_interface_list(RustBuffer, RustCallStatus*);
  int8_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_bool(int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_compound(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_enum(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_rec(RustBuffer, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_custom_type(uint64_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_no_data(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_with_data(RustBuffer, RustCallStatus*);
  float uniffi_uniffi_bindings_tests_fn_func_roundtrip_f32(float, RustCallStatus*);
  double uniffi_uniffi_bindings_tests_fn_func_roundtrip_f64(double, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_hash_map(RustBuffer, RustCallStatus*);
  int16_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_i16(int16_t, RustCallStatus*);
  int32_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_i32(int32_t, RustCallStatus*);
  int64_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_i64(int64_t, RustCallStatus*);
  int8_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_i8(int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_option(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_simple_rec(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_string(RustBuffer, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_test_trait_interface(uint64_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_test_trait_interface_list(RustBuffer, RustCallStatus*);
  int64_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_time_interval_ms(int64_t, RustCallStatus*);
  double uniffi_uniffi_bindings_tests_fn_func_roundtrip_time_interval_sec_dbl(double, RustCallStatus*);
  float uniffi_uniffi_bindings_tests_fn_func_roundtrip_time_interval_sec_flt(float, RustCallStatus*);
  uint16_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_u16(uint16_t, RustCallStatus*);
  uint32_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_u32(uint32_t, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_u64(uint64_t, RustCallStatus*);
  uint8_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_u8(uint8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_url(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_vec(RustBuffer, RustCallStatus*);
  double uniffi_uniffi_bindings_tests_fn_func_sum_with_many_types(uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t, uint64_t, int64_t, float, double, int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_swap_test_interfaces(RustBuffer, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_test_func(RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_constructor_asyncinterface_new(RustBuffer, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_method_asyncinterface_name(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_method_asynctesttraitinterface_noop(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_method_asynctesttraitinterface_get_value(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_method_asynctesttraitinterface_set_value(uint64_t, uint32_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_method_asynctesttraitinterface_throw_if_equal(uint64_t, RustBuffer);
  uint64_t uniffi_uniffi_bindings_tests_fn_constructor_complexmethods_new(RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_default(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_multi_word_arg(uint64_t, RustBuffer, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_constructor_testinterface_new(uint32_t, RustCallStatus*);
  uint32_t uniffi_uniffi_bindings_tests_fn_method_testinterface_get_value(uint64_t, RustCallStatus*);
  uint32_t uniffi_uniffi_bindings_tests_fn_method_testinterface_ref_count(uint64_t, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_noop(uint64_t, RustCallStatus*);
  uint32_t uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_get_value(uint64_t, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_set_value(uint64_t, uint32_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_throw_if_equal(uint64_t, RustBuffer, RustCallStatus*);
  uint32_t ffi_uniffi_bindings_tests_uniffi_contract_version();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_f32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_f64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_i16();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_i32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_i64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_i8();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_map();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_obj();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_string();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_u16();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_u32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_u64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_u8();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_vec();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_throw_error();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_clone_interface();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_create_async_test_trait_interface();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_create_test_trait_interface();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_func_with_default();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_func_with_error();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_func_with_flat_error();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_func_with_multi_word_arg();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_get_custom_types_demo();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_async_test_trait_interface_get_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_async_test_trait_interface_noop();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_async_test_trait_interface_set_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_async_test_trait_interface_throw_if_equal();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_async_callback_interface_get_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_async_callback_interface_noop();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_async_callback_interface_set_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_async_callback_interface_throw_if_equal();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_callback_interface_get_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_callback_interface_noop();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_callback_interface_set_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_callback_interface_throw_if_equal();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_trait_interface_get_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_trait_interface_noop();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_trait_interface_set_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_trait_interface_throw_if_equal();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_async_test_trait_interface();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_async_test_trait_interface_list();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_bool();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_complex_compound();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_complex_enum();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_complex_rec();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_custom_type();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_enum_no_data();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_enum_with_data();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_f32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_f64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_hash_map();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_i16();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_i32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_i64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_i8();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_option();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_simple_rec();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_string();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_test_trait_interface();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_test_trait_interface_list();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_time_interval_ms();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_time_interval_sec_dbl();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_time_interval_sec_flt();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_u16();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_u32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_u64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_u8();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_url();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_vec();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_sum_with_many_types();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_swap_test_interfaces();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_test_func();
  uint16_t uniffi_uniffi_bindings_tests_checksum_constructor_asyncinterface_new();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_asyncinterface_name();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_asynctesttraitinterface_noop();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_asynctesttraitinterface_get_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_asynctesttraitinterface_set_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_asynctesttraitinterface_throw_if_equal();
  uint16_t uniffi_uniffi_bindings_tests_checksum_constructor_complexmethods_new();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_complexmethods_method_with_default();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_complexmethods_method_with_multi_word_arg();
  uint16_t uniffi_uniffi_bindings_tests_checksum_constructor_testinterface_new();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_testinterface_get_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_testinterface_ref_count();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_testtraitinterface_noop();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_testtraitinterface_get_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_testtraitinterface_set_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_testtraitinterface_throw_if_equal();
  RustBuffer ffi_uniffi_bindings_tests_collision_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_bindings_tests_collision_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_bindings_tests_collision_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_uniffi_bindings_tests_collision_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_u8(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_i8(uint64_t);
  int8_t ffi_uniffi_bindings_tests_collision_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_i8(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_uniffi_bindings_tests_collision_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_u16(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_i16(uint64_t);
  int16_t ffi_uniffi_bindings_tests_collision_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_i16(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_uniffi_bindings_tests_collision_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_u32(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_i32(uint64_t);
  int32_t ffi_uniffi_bindings_tests_collision_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_i32(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_uniffi_bindings_tests_collision_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_u64(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_i64(uint64_t);
  int64_t ffi_uniffi_bindings_tests_collision_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_i64(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_f32(uint64_t);
  float ffi_uniffi_bindings_tests_collision_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_f32(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_f64(uint64_t);
  double ffi_uniffi_bindings_tests_collision_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_f64(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_bindings_tests_collision_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_rust_buffer(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_void(uint64_t);
  typedef void (*CallbackInterfaceUniffiBindingsTestsCollisionTestCallbackInterfaceMethod0)(uint64_t, RustBuffer*, RustCallStatus*);
  typedef uint64_t (*CallbackInterfaceCloneUniffiBindingsTestsCollision_TestCallbackInterface)(uint64_t);
  typedef void (*CallbackInterfaceFreeUniffiBindingsTestsCollision_TestCallbackInterface)(uint64_t);
  struct VTableCallbackInterfaceUniffiBindingsTestsCollisionTestCallbackInterface {
    CallbackInterfaceFreeUniffiBindingsTestsCollision_TestCallbackInterface uniffi_free;
    CallbackInterfaceCloneUniffiBindingsTestsCollision_TestCallbackInterface uniffi_clone;
    CallbackInterfaceUniffiBindingsTestsCollisionTestCallbackInterfaceMethod0 get_value;
  };
  void uniffi_uniffi_bindings_tests_collision_fn_init_callback_vtable_testcallbackinterface(VTableCallbackInterfaceUniffiBindingsTestsCollisionTestCallbackInterface*);
  RustBuffer uniffi_uniffi_bindings_tests_collision_fn_func_invoke_collision_callback(uint64_t, RustCallStatus*);
  uint32_t ffi_uniffi_bindings_tests_collision_uniffi_contract_version();
  uint16_t uniffi_uniffi_bindings_tests_collision_checksum_func_invoke_collision_callback();
  RustBuffer ffi_uniffi_bindings_tests_external_types_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_bindings_tests_external_types_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_bindings_tests_external_types_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_u8(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_i8(uint64_t);
  int8_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_i8(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_u16(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_i16(uint64_t);
  int16_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_i16(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_u32(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_i32(uint64_t);
  int32_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_i32(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_u64(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_i64(uint64_t);
  int64_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_i64(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_f32(uint64_t);
  float ffi_uniffi_bindings_tests_external_types_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_f32(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_f64(uint64_t);
  double ffi_uniffi_bindings_tests_external_types_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_f64(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_bindings_tests_external_types_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_rust_buffer(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_void(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_custom_type(uint64_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_enum(RustBuffer, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_interface(uint64_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_record(RustBuffer, RustCallStatus*);
  uint32_t ffi_uniffi_bindings_tests_external_types_uniffi_contract_version();
  uint16_t uniffi_uniffi_bindings_tests_external_types_checksum_func_roundtrip_ext_custom_type();
  uint16_t uniffi_uniffi_bindings_tests_external_types_checksum_func_roundtrip_ext_enum();
  uint16_t uniffi_uniffi_bindings_tests_external_types_checksum_func_roundtrip_ext_interface();
  uint16_t uniffi_uniffi_bindings_tests_external_types_checksum_func_roundtrip_ext_record();
#endif /* MOZ_UNIFFI_FIXTURES */
}
/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

// Define pointer types

const static mozilla::uniffi::UniFFIPointerType kContextIdContextIdComponentPointerType {
  "context_id::ContextIDComponent"_ns,
  uniffi_context_id_fn_clone_contextidcomponent,
  uniffi_context_id_fn_free_contextidcomponent,
};
class FfiValueObjectHandleContextIdContextIdComponent {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleContextIdContextIdComponent() = default;
  explicit FfiValueObjectHandleContextIdContextIdComponent(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleContextIdContextIdComponent(const FfiValueObjectHandleContextIdContextIdComponent&) = delete;
  FfiValueObjectHandleContextIdContextIdComponent& operator=(const FfiValueObjectHandleContextIdContextIdComponent&) = delete;

  FfiValueObjectHandleContextIdContextIdComponent& operator=(FfiValueObjectHandleContextIdContextIdComponent&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kContextIdContextIdComponentPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kContextIdContextIdComponentPointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleContextIdContextIdComponent FromRust(uint64_t aValue) {
    return FfiValueObjectHandleContextIdContextIdComponent(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_context_id_fn_free_contextidcomponent)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleContextIdContextIdComponent() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kFilterAdultFilterAdultComponentPointerType {
  "filter_adult::FilterAdultComponent"_ns,
  uniffi_filter_adult_fn_clone_filteradultcomponent,
  uniffi_filter_adult_fn_free_filteradultcomponent,
};
class FfiValueObjectHandleFilterAdultFilterAdultComponent {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleFilterAdultFilterAdultComponent() = default;
  explicit FfiValueObjectHandleFilterAdultFilterAdultComponent(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleFilterAdultFilterAdultComponent(const FfiValueObjectHandleFilterAdultFilterAdultComponent&) = delete;
  FfiValueObjectHandleFilterAdultFilterAdultComponent& operator=(const FfiValueObjectHandleFilterAdultFilterAdultComponent&) = delete;

  FfiValueObjectHandleFilterAdultFilterAdultComponent& operator=(FfiValueObjectHandleFilterAdultFilterAdultComponent&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kFilterAdultFilterAdultComponentPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kFilterAdultFilterAdultComponentPointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleFilterAdultFilterAdultComponent FromRust(uint64_t aValue) {
    return FfiValueObjectHandleFilterAdultFilterAdultComponent(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_filter_adult_fn_free_filteradultcomponent)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleFilterAdultFilterAdultComponent() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kLoginsEncryptorDecryptorPointerType {
  "logins::EncryptorDecryptor"_ns,
  uniffi_logins_fn_clone_encryptordecryptor,
  uniffi_logins_fn_free_encryptordecryptor,
};
// Forward declare the free and clone functions, which are defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_logins_encryptor_decryptor(uint64_t uniffiHandle);
extern "C" uint64_t callback_clone_logins_encryptor_decryptor(uint64_t uniffiHandle);

// Trait interface FFI value class.  This is a hybrid between the one for interfaces and callback
// interface version
class FfiValueObjectHandleLoginsEncryptorDecryptor {
 private:
  // The raw FFI value is a uint64_t in all cases.
  // For callback interfaces, the uint64_t handle gets casted to a pointer.  Callback interface
  // handles are used as the uint64_t and are incremented by one at a time, so even on a 32-bit system this
  // shouldn't overflow.
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleLoginsEncryptorDecryptor() = default;
  explicit FfiValueObjectHandleLoginsEncryptorDecryptor(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleLoginsEncryptorDecryptor(const FfiValueObjectHandleLoginsEncryptorDecryptor&) = delete;
  FfiValueObjectHandleLoginsEncryptorDecryptor& operator=(const FfiValueObjectHandleLoginsEncryptorDecryptor&) = delete;

  FfiValueObjectHandleLoginsEncryptorDecryptor& operator=(FfiValueObjectHandleLoginsEncryptorDecryptor&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  // Lower a trait interface, `aValue` can either be a Rust or JS handle
  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    FreeHandle();
    if (aValue.IsUniFFIPointer()) {
      // Rust handle.  Clone the handle and return it.
      dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
      if (!value.IsSamePtrType(&kLoginsEncryptorDecryptorPointerType)) {
        aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
        return;
      }
      mValue = value.ClonePtr();
    } else if (aValue.IsDouble()) {
      // JS handle.  Just return it, the JS code has already incremented the
      // refcount
      double floatValue = aValue.GetAsDouble();
      uint64_t intValue = static_cast<uint64_t>(floatValue);
      if (intValue != floatValue) {
        aError.ThrowTypeError("Not an integer"_ns);
        return;
      }
      mValue = intValue;
    } else {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
  }

  // Lift a trait interface.  `mValue` can either by a Rust or JS handle
  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    if ((mValue & 1) == 0) {
      // Rust handle
      aDest->SetAsUniFFIPointer() =
          dom::UniFFIPointer::Create(mValue, &kLoginsEncryptorDecryptorPointerType);
    } else {
      // JS handle
      aDest->SetAsDouble() = mValue;
    }
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleLoginsEncryptorDecryptor FromRust(uint64_t aValue) {
    return FfiValueObjectHandleLoginsEncryptorDecryptor(aValue);
  }

  void FreeHandle() {
    // If we're storing a handle, call the free function for it. The function to
    // call depends on if we're holding a JS or Rust implementation of the
    // interface. We can tell that by looking at the lowest bit of the handle
    if (mValue == 0) {
      // 0 indicates we're not storing a handle.
    } else if ((mValue & 1) == 0) {
      // Rust implementation
      RustCallStatus callStatus{};
      (uniffi_logins_fn_free_encryptordecryptor)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    } else {
      // JS implementation
      callback_free_logins_encryptor_decryptor(mValue);
    }
    mValue = 0;
  }

  ~FfiValueObjectHandleLoginsEncryptorDecryptor() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kLoginsKeyManagerPointerType {
  "logins::KeyManager"_ns,
  uniffi_logins_fn_clone_keymanager,
  uniffi_logins_fn_free_keymanager,
};
// Forward declare the free and clone functions, which are defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_logins_key_manager(uint64_t uniffiHandle);
extern "C" uint64_t callback_clone_logins_key_manager(uint64_t uniffiHandle);

// Trait interface FFI value class.  This is a hybrid between the one for interfaces and callback
// interface version
class FfiValueObjectHandleLoginsKeyManager {
 private:
  // The raw FFI value is a uint64_t in all cases.
  // For callback interfaces, the uint64_t handle gets casted to a pointer.  Callback interface
  // handles are used as the uint64_t and are incremented by one at a time, so even on a 32-bit system this
  // shouldn't overflow.
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleLoginsKeyManager() = default;
  explicit FfiValueObjectHandleLoginsKeyManager(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleLoginsKeyManager(const FfiValueObjectHandleLoginsKeyManager&) = delete;
  FfiValueObjectHandleLoginsKeyManager& operator=(const FfiValueObjectHandleLoginsKeyManager&) = delete;

  FfiValueObjectHandleLoginsKeyManager& operator=(FfiValueObjectHandleLoginsKeyManager&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  // Lower a trait interface, `aValue` can either be a Rust or JS handle
  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    FreeHandle();
    if (aValue.IsUniFFIPointer()) {
      // Rust handle.  Clone the handle and return it.
      dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
      if (!value.IsSamePtrType(&kLoginsKeyManagerPointerType)) {
        aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
        return;
      }
      mValue = value.ClonePtr();
    } else if (aValue.IsDouble()) {
      // JS handle.  Just return it, the JS code has already incremented the
      // refcount
      double floatValue = aValue.GetAsDouble();
      uint64_t intValue = static_cast<uint64_t>(floatValue);
      if (intValue != floatValue) {
        aError.ThrowTypeError("Not an integer"_ns);
        return;
      }
      mValue = intValue;
    } else {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
  }

  // Lift a trait interface.  `mValue` can either by a Rust or JS handle
  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    if ((mValue & 1) == 0) {
      // Rust handle
      aDest->SetAsUniFFIPointer() =
          dom::UniFFIPointer::Create(mValue, &kLoginsKeyManagerPointerType);
    } else {
      // JS handle
      aDest->SetAsDouble() = mValue;
    }
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleLoginsKeyManager FromRust(uint64_t aValue) {
    return FfiValueObjectHandleLoginsKeyManager(aValue);
  }

  void FreeHandle() {
    // If we're storing a handle, call the free function for it. The function to
    // call depends on if we're holding a JS or Rust implementation of the
    // interface. We can tell that by looking at the lowest bit of the handle
    if (mValue == 0) {
      // 0 indicates we're not storing a handle.
    } else if ((mValue & 1) == 0) {
      // Rust implementation
      RustCallStatus callStatus{};
      (uniffi_logins_fn_free_keymanager)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    } else {
      // JS implementation
      callback_free_logins_key_manager(mValue);
    }
    mValue = 0;
  }

  ~FfiValueObjectHandleLoginsKeyManager() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kLoginsLoginStorePointerType {
  "logins::LoginStore"_ns,
  uniffi_logins_fn_clone_loginstore,
  uniffi_logins_fn_free_loginstore,
};
class FfiValueObjectHandleLoginsLoginStore {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleLoginsLoginStore() = default;
  explicit FfiValueObjectHandleLoginsLoginStore(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleLoginsLoginStore(const FfiValueObjectHandleLoginsLoginStore&) = delete;
  FfiValueObjectHandleLoginsLoginStore& operator=(const FfiValueObjectHandleLoginsLoginStore&) = delete;

  FfiValueObjectHandleLoginsLoginStore& operator=(FfiValueObjectHandleLoginsLoginStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kLoginsLoginStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kLoginsLoginStorePointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleLoginsLoginStore FromRust(uint64_t aValue) {
    return FfiValueObjectHandleLoginsLoginStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_logins_fn_free_loginstore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleLoginsLoginStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kLoginsManagedEncryptorDecryptorPointerType {
  "logins::ManagedEncryptorDecryptor"_ns,
  uniffi_logins_fn_clone_managedencryptordecryptor,
  uniffi_logins_fn_free_managedencryptordecryptor,
};
class FfiValueObjectHandleLoginsManagedEncryptorDecryptor {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleLoginsManagedEncryptorDecryptor() = default;
  explicit FfiValueObjectHandleLoginsManagedEncryptorDecryptor(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleLoginsManagedEncryptorDecryptor(const FfiValueObjectHandleLoginsManagedEncryptorDecryptor&) = delete;
  FfiValueObjectHandleLoginsManagedEncryptorDecryptor& operator=(const FfiValueObjectHandleLoginsManagedEncryptorDecryptor&) = delete;

  FfiValueObjectHandleLoginsManagedEncryptorDecryptor& operator=(FfiValueObjectHandleLoginsManagedEncryptorDecryptor&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kLoginsManagedEncryptorDecryptorPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kLoginsManagedEncryptorDecryptorPointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleLoginsManagedEncryptorDecryptor FromRust(uint64_t aValue) {
    return FfiValueObjectHandleLoginsManagedEncryptorDecryptor(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_logins_fn_free_managedencryptordecryptor)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleLoginsManagedEncryptorDecryptor() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kLoginsNssKeyManagerPointerType {
  "logins::NSSKeyManager"_ns,
  uniffi_logins_fn_clone_nsskeymanager,
  uniffi_logins_fn_free_nsskeymanager,
};
class FfiValueObjectHandleLoginsNssKeyManager {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleLoginsNssKeyManager() = default;
  explicit FfiValueObjectHandleLoginsNssKeyManager(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleLoginsNssKeyManager(const FfiValueObjectHandleLoginsNssKeyManager&) = delete;
  FfiValueObjectHandleLoginsNssKeyManager& operator=(const FfiValueObjectHandleLoginsNssKeyManager&) = delete;

  FfiValueObjectHandleLoginsNssKeyManager& operator=(FfiValueObjectHandleLoginsNssKeyManager&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kLoginsNssKeyManagerPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kLoginsNssKeyManagerPointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleLoginsNssKeyManager FromRust(uint64_t aValue) {
    return FfiValueObjectHandleLoginsNssKeyManager(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_logins_fn_free_nsskeymanager)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleLoginsNssKeyManager() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kLoginsPrimaryPasswordAuthenticatorPointerType {
  "logins::PrimaryPasswordAuthenticator"_ns,
  uniffi_logins_fn_clone_primarypasswordauthenticator,
  uniffi_logins_fn_free_primarypasswordauthenticator,
};
// Forward declare the free and clone functions, which are defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_logins_primary_password_authenticator(uint64_t uniffiHandle);
extern "C" uint64_t callback_clone_logins_primary_password_authenticator(uint64_t uniffiHandle);

// Trait interface FFI value class.  This is a hybrid between the one for interfaces and callback
// interface version
class FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator {
 private:
  // The raw FFI value is a uint64_t in all cases.
  // For callback interfaces, the uint64_t handle gets casted to a pointer.  Callback interface
  // handles are used as the uint64_t and are incremented by one at a time, so even on a 32-bit system this
  // shouldn't overflow.
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator() = default;
  explicit FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator(const FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator&) = delete;
  FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator& operator=(const FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator&) = delete;

  FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator& operator=(FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  // Lower a trait interface, `aValue` can either be a Rust or JS handle
  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    FreeHandle();
    if (aValue.IsUniFFIPointer()) {
      // Rust handle.  Clone the handle and return it.
      dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
      if (!value.IsSamePtrType(&kLoginsPrimaryPasswordAuthenticatorPointerType)) {
        aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
        return;
      }
      mValue = value.ClonePtr();
    } else if (aValue.IsDouble()) {
      // JS handle.  Just return it, the JS code has already incremented the
      // refcount
      double floatValue = aValue.GetAsDouble();
      uint64_t intValue = static_cast<uint64_t>(floatValue);
      if (intValue != floatValue) {
        aError.ThrowTypeError("Not an integer"_ns);
        return;
      }
      mValue = intValue;
    } else {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
  }

  // Lift a trait interface.  `mValue` can either by a Rust or JS handle
  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    if ((mValue & 1) == 0) {
      // Rust handle
      aDest->SetAsUniFFIPointer() =
          dom::UniFFIPointer::Create(mValue, &kLoginsPrimaryPasswordAuthenticatorPointerType);
    } else {
      // JS handle
      aDest->SetAsDouble() = mValue;
    }
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator FromRust(uint64_t aValue) {
    return FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator(aValue);
  }

  void FreeHandle() {
    // If we're storing a handle, call the free function for it. The function to
    // call depends on if we're holding a JS or Rust implementation of the
    // interface. We can tell that by looking at the lowest bit of the handle
    if (mValue == 0) {
      // 0 indicates we're not storing a handle.
    } else if ((mValue & 1) == 0) {
      // Rust implementation
      RustCallStatus callStatus{};
      (uniffi_logins_fn_free_primarypasswordauthenticator)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    } else {
      // JS implementation
      callback_free_logins_primary_password_authenticator(mValue);
    }
    mValue = 0;
  }

  ~FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kLoginsStaticKeyManagerPointerType {
  "logins::StaticKeyManager"_ns,
  uniffi_logins_fn_clone_statickeymanager,
  uniffi_logins_fn_free_statickeymanager,
};
class FfiValueObjectHandleLoginsStaticKeyManager {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleLoginsStaticKeyManager() = default;
  explicit FfiValueObjectHandleLoginsStaticKeyManager(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleLoginsStaticKeyManager(const FfiValueObjectHandleLoginsStaticKeyManager&) = delete;
  FfiValueObjectHandleLoginsStaticKeyManager& operator=(const FfiValueObjectHandleLoginsStaticKeyManager&) = delete;

  FfiValueObjectHandleLoginsStaticKeyManager& operator=(FfiValueObjectHandleLoginsStaticKeyManager&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kLoginsStaticKeyManagerPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kLoginsStaticKeyManagerPointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleLoginsStaticKeyManager FromRust(uint64_t aValue) {
    return FfiValueObjectHandleLoginsStaticKeyManager(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_logins_fn_free_statickeymanager)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleLoginsStaticKeyManager() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRelevancyRelevancyStorePointerType {
  "relevancy::RelevancyStore"_ns,
  uniffi_relevancy_fn_clone_relevancystore,
  uniffi_relevancy_fn_free_relevancystore,
};
class FfiValueObjectHandleRelevancyRelevancyStore {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleRelevancyRelevancyStore() = default;
  explicit FfiValueObjectHandleRelevancyRelevancyStore(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRelevancyRelevancyStore(const FfiValueObjectHandleRelevancyRelevancyStore&) = delete;
  FfiValueObjectHandleRelevancyRelevancyStore& operator=(const FfiValueObjectHandleRelevancyRelevancyStore&) = delete;

  FfiValueObjectHandleRelevancyRelevancyStore& operator=(FfiValueObjectHandleRelevancyRelevancyStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRelevancyRelevancyStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRelevancyRelevancyStorePointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleRelevancyRelevancyStore FromRust(uint64_t aValue) {
    return FfiValueObjectHandleRelevancyRelevancyStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_relevancy_fn_free_relevancystore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRelevancyRelevancyStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRemoteSettingsRemoteSettingsPointerType {
  "remote_settings::RemoteSettings"_ns,
  uniffi_remote_settings_fn_clone_remotesettings,
  uniffi_remote_settings_fn_free_remotesettings,
};
class FfiValueObjectHandleRemoteSettingsRemoteSettings {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleRemoteSettingsRemoteSettings() = default;
  explicit FfiValueObjectHandleRemoteSettingsRemoteSettings(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRemoteSettingsRemoteSettings(const FfiValueObjectHandleRemoteSettingsRemoteSettings&) = delete;
  FfiValueObjectHandleRemoteSettingsRemoteSettings& operator=(const FfiValueObjectHandleRemoteSettingsRemoteSettings&) = delete;

  FfiValueObjectHandleRemoteSettingsRemoteSettings& operator=(FfiValueObjectHandleRemoteSettingsRemoteSettings&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRemoteSettingsRemoteSettingsPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRemoteSettingsRemoteSettingsPointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleRemoteSettingsRemoteSettings FromRust(uint64_t aValue) {
    return FfiValueObjectHandleRemoteSettingsRemoteSettings(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_remote_settings_fn_free_remotesettings)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRemoteSettingsRemoteSettings() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRemoteSettingsRemoteSettingsClientPointerType {
  "remote_settings::RemoteSettingsClient"_ns,
  uniffi_remote_settings_fn_clone_remotesettingsclient,
  uniffi_remote_settings_fn_free_remotesettingsclient,
};
class FfiValueObjectHandleRemoteSettingsRemoteSettingsClient {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient() = default;
  explicit FfiValueObjectHandleRemoteSettingsRemoteSettingsClient(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient(const FfiValueObjectHandleRemoteSettingsRemoteSettingsClient&) = delete;
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient& operator=(const FfiValueObjectHandleRemoteSettingsRemoteSettingsClient&) = delete;

  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient& operator=(FfiValueObjectHandleRemoteSettingsRemoteSettingsClient&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRemoteSettingsRemoteSettingsClientPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRemoteSettingsRemoteSettingsClientPointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleRemoteSettingsRemoteSettingsClient FromRust(uint64_t aValue) {
    return FfiValueObjectHandleRemoteSettingsRemoteSettingsClient(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_remote_settings_fn_free_remotesettingsclient)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRemoteSettingsRemoteSettingsClient() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRemoteSettingsRemoteSettingsServicePointerType {
  "remote_settings::RemoteSettingsService"_ns,
  uniffi_remote_settings_fn_clone_remotesettingsservice,
  uniffi_remote_settings_fn_free_remotesettingsservice,
};
class FfiValueObjectHandleRemoteSettingsRemoteSettingsService {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService() = default;
  explicit FfiValueObjectHandleRemoteSettingsRemoteSettingsService(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService(const FfiValueObjectHandleRemoteSettingsRemoteSettingsService&) = delete;
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService& operator=(const FfiValueObjectHandleRemoteSettingsRemoteSettingsService&) = delete;

  FfiValueObjectHandleRemoteSettingsRemoteSettingsService& operator=(FfiValueObjectHandleRemoteSettingsRemoteSettingsService&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRemoteSettingsRemoteSettingsServicePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRemoteSettingsRemoteSettingsServicePointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleRemoteSettingsRemoteSettingsService FromRust(uint64_t aValue) {
    return FfiValueObjectHandleRemoteSettingsRemoteSettingsService(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_remote_settings_fn_free_remotesettingsservice)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRemoteSettingsRemoteSettingsService() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kSearchSearchEngineSelectorPointerType {
  "search::SearchEngineSelector"_ns,
  uniffi_search_fn_clone_searchengineselector,
  uniffi_search_fn_free_searchengineselector,
};
class FfiValueObjectHandleSearchSearchEngineSelector {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleSearchSearchEngineSelector() = default;
  explicit FfiValueObjectHandleSearchSearchEngineSelector(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleSearchSearchEngineSelector(const FfiValueObjectHandleSearchSearchEngineSelector&) = delete;
  FfiValueObjectHandleSearchSearchEngineSelector& operator=(const FfiValueObjectHandleSearchSearchEngineSelector&) = delete;

  FfiValueObjectHandleSearchSearchEngineSelector& operator=(FfiValueObjectHandleSearchSearchEngineSelector&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kSearchSearchEngineSelectorPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kSearchSearchEngineSelectorPointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleSearchSearchEngineSelector FromRust(uint64_t aValue) {
    return FfiValueObjectHandleSearchSearchEngineSelector(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_search_fn_free_searchengineselector)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleSearchSearchEngineSelector() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kSuggestSuggestStorePointerType {
  "suggest::SuggestStore"_ns,
  uniffi_suggest_fn_clone_suggeststore,
  uniffi_suggest_fn_free_suggeststore,
};
class FfiValueObjectHandleSuggestSuggestStore {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleSuggestSuggestStore() = default;
  explicit FfiValueObjectHandleSuggestSuggestStore(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleSuggestSuggestStore(const FfiValueObjectHandleSuggestSuggestStore&) = delete;
  FfiValueObjectHandleSuggestSuggestStore& operator=(const FfiValueObjectHandleSuggestSuggestStore&) = delete;

  FfiValueObjectHandleSuggestSuggestStore& operator=(FfiValueObjectHandleSuggestSuggestStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kSuggestSuggestStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kSuggestSuggestStorePointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleSuggestSuggestStore FromRust(uint64_t aValue) {
    return FfiValueObjectHandleSuggestSuggestStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_suggest_fn_free_suggeststore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleSuggestSuggestStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kSuggestSuggestStoreBuilderPointerType {
  "suggest::SuggestStoreBuilder"_ns,
  uniffi_suggest_fn_clone_suggeststorebuilder,
  uniffi_suggest_fn_free_suggeststorebuilder,
};
class FfiValueObjectHandleSuggestSuggestStoreBuilder {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleSuggestSuggestStoreBuilder() = default;
  explicit FfiValueObjectHandleSuggestSuggestStoreBuilder(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleSuggestSuggestStoreBuilder(const FfiValueObjectHandleSuggestSuggestStoreBuilder&) = delete;
  FfiValueObjectHandleSuggestSuggestStoreBuilder& operator=(const FfiValueObjectHandleSuggestSuggestStoreBuilder&) = delete;

  FfiValueObjectHandleSuggestSuggestStoreBuilder& operator=(FfiValueObjectHandleSuggestSuggestStoreBuilder&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kSuggestSuggestStoreBuilderPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kSuggestSuggestStoreBuilderPointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleSuggestSuggestStoreBuilder FromRust(uint64_t aValue) {
    return FfiValueObjectHandleSuggestSuggestStoreBuilder(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_suggest_fn_free_suggeststorebuilder)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleSuggestSuggestStoreBuilder() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kTabsRemoteCommandStorePointerType {
  "tabs::RemoteCommandStore"_ns,
  uniffi_tabs_fn_clone_remotecommandstore,
  uniffi_tabs_fn_free_remotecommandstore,
};
class FfiValueObjectHandleTabsRemoteCommandStore {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleTabsRemoteCommandStore() = default;
  explicit FfiValueObjectHandleTabsRemoteCommandStore(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleTabsRemoteCommandStore(const FfiValueObjectHandleTabsRemoteCommandStore&) = delete;
  FfiValueObjectHandleTabsRemoteCommandStore& operator=(const FfiValueObjectHandleTabsRemoteCommandStore&) = delete;

  FfiValueObjectHandleTabsRemoteCommandStore& operator=(FfiValueObjectHandleTabsRemoteCommandStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kTabsRemoteCommandStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kTabsRemoteCommandStorePointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleTabsRemoteCommandStore FromRust(uint64_t aValue) {
    return FfiValueObjectHandleTabsRemoteCommandStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_tabs_fn_free_remotecommandstore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleTabsRemoteCommandStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kTabsTabsBridgedEnginePointerType {
  "tabs::TabsBridgedEngine"_ns,
  uniffi_tabs_fn_clone_tabsbridgedengine,
  uniffi_tabs_fn_free_tabsbridgedengine,
};
class FfiValueObjectHandleTabsTabsBridgedEngine {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleTabsTabsBridgedEngine() = default;
  explicit FfiValueObjectHandleTabsTabsBridgedEngine(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleTabsTabsBridgedEngine(const FfiValueObjectHandleTabsTabsBridgedEngine&) = delete;
  FfiValueObjectHandleTabsTabsBridgedEngine& operator=(const FfiValueObjectHandleTabsTabsBridgedEngine&) = delete;

  FfiValueObjectHandleTabsTabsBridgedEngine& operator=(FfiValueObjectHandleTabsTabsBridgedEngine&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kTabsTabsBridgedEnginePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kTabsTabsBridgedEnginePointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleTabsTabsBridgedEngine FromRust(uint64_t aValue) {
    return FfiValueObjectHandleTabsTabsBridgedEngine(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_tabs_fn_free_tabsbridgedengine)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleTabsTabsBridgedEngine() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kTabsTabsStorePointerType {
  "tabs::TabsStore"_ns,
  uniffi_tabs_fn_clone_tabsstore,
  uniffi_tabs_fn_free_tabsstore,
};
class FfiValueObjectHandleTabsTabsStore {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleTabsTabsStore() = default;
  explicit FfiValueObjectHandleTabsTabsStore(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleTabsTabsStore(const FfiValueObjectHandleTabsTabsStore&) = delete;
  FfiValueObjectHandleTabsTabsStore& operator=(const FfiValueObjectHandleTabsTabsStore&) = delete;

  FfiValueObjectHandleTabsTabsStore& operator=(FfiValueObjectHandleTabsTabsStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kTabsTabsStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kTabsTabsStorePointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleTabsTabsStore FromRust(uint64_t aValue) {
    return FfiValueObjectHandleTabsTabsStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_tabs_fn_free_tabsstore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleTabsTabsStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kViaductBackendPointerType {
  "viaduct::Backend"_ns,
  uniffi_viaduct_fn_clone_backend,
  uniffi_viaduct_fn_free_backend,
};
// Forward declare the free and clone functions, which are defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_viaduct_backend(uint64_t uniffiHandle);
extern "C" uint64_t callback_clone_viaduct_backend(uint64_t uniffiHandle);

// Trait interface FFI value class.  This is a hybrid between the one for interfaces and callback
// interface version
class FfiValueObjectHandleViaductBackend {
 private:
  // The raw FFI value is a uint64_t in all cases.
  // For callback interfaces, the uint64_t handle gets casted to a pointer.  Callback interface
  // handles are used as the uint64_t and are incremented by one at a time, so even on a 32-bit system this
  // shouldn't overflow.
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleViaductBackend() = default;
  explicit FfiValueObjectHandleViaductBackend(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleViaductBackend(const FfiValueObjectHandleViaductBackend&) = delete;
  FfiValueObjectHandleViaductBackend& operator=(const FfiValueObjectHandleViaductBackend&) = delete;

  FfiValueObjectHandleViaductBackend& operator=(FfiValueObjectHandleViaductBackend&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  // Lower a trait interface, `aValue` can either be a Rust or JS handle
  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    FreeHandle();
    if (aValue.IsUniFFIPointer()) {
      // Rust handle.  Clone the handle and return it.
      dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
      if (!value.IsSamePtrType(&kViaductBackendPointerType)) {
        aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
        return;
      }
      mValue = value.ClonePtr();
    } else if (aValue.IsDouble()) {
      // JS handle.  Just return it, the JS code has already incremented the
      // refcount
      double floatValue = aValue.GetAsDouble();
      uint64_t intValue = static_cast<uint64_t>(floatValue);
      if (intValue != floatValue) {
        aError.ThrowTypeError("Not an integer"_ns);
        return;
      }
      mValue = intValue;
    } else {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
  }

  // Lift a trait interface.  `mValue` can either by a Rust or JS handle
  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    if ((mValue & 1) == 0) {
      // Rust handle
      aDest->SetAsUniFFIPointer() =
          dom::UniFFIPointer::Create(mValue, &kViaductBackendPointerType);
    } else {
      // JS handle
      aDest->SetAsDouble() = mValue;
    }
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleViaductBackend FromRust(uint64_t aValue) {
    return FfiValueObjectHandleViaductBackend(aValue);
  }

  void FreeHandle() {
    // If we're storing a handle, call the free function for it. The function to
    // call depends on if we're holding a JS or Rust implementation of the
    // interface. We can tell that by looking at the lowest bit of the handle
    if (mValue == 0) {
      // 0 indicates we're not storing a handle.
    } else if ((mValue & 1) == 0) {
      // Rust implementation
      RustCallStatus callStatus{};
      (uniffi_viaduct_fn_free_backend)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    } else {
      // JS implementation
      callback_free_viaduct_backend(mValue);
    }
    mValue = 0;
  }

  ~FfiValueObjectHandleViaductBackend() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kWebextstorageWebExtStorageBridgedEnginePointerType {
  "webextstorage::WebExtStorageBridgedEngine"_ns,
  uniffi_webext_storage_fn_clone_webextstoragebridgedengine,
  uniffi_webext_storage_fn_free_webextstoragebridgedengine,
};
class FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine() = default;
  explicit FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine(const FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine&) = delete;
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine& operator=(const FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine&) = delete;

  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine& operator=(FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kWebextstorageWebExtStorageBridgedEnginePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kWebextstorageWebExtStorageBridgedEnginePointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine FromRust(uint64_t aValue) {
    return FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_webext_storage_fn_free_webextstoragebridgedengine)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kWebextstorageWebExtStorageStorePointerType {
  "webextstorage::WebExtStorageStore"_ns,
  uniffi_webext_storage_fn_clone_webextstoragestore,
  uniffi_webext_storage_fn_free_webextstoragestore,
};
class FfiValueObjectHandleWebextstorageWebExtStorageStore {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleWebextstorageWebExtStorageStore() = default;
  explicit FfiValueObjectHandleWebextstorageWebExtStorageStore(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleWebextstorageWebExtStorageStore(const FfiValueObjectHandleWebextstorageWebExtStorageStore&) = delete;
  FfiValueObjectHandleWebextstorageWebExtStorageStore& operator=(const FfiValueObjectHandleWebextstorageWebExtStorageStore&) = delete;

  FfiValueObjectHandleWebextstorageWebExtStorageStore& operator=(FfiValueObjectHandleWebextstorageWebExtStorageStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kWebextstorageWebExtStorageStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kWebextstorageWebExtStorageStorePointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleWebextstorageWebExtStorageStore FromRust(uint64_t aValue) {
    return FfiValueObjectHandleWebextstorageWebExtStorageStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_webext_storage_fn_free_webextstoragestore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleWebextstorageWebExtStorageStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};

#ifdef MOZ_UNIFFI_FIXTURES
const static mozilla::uniffi::UniFFIPointerType kUniffiBindingsTestsTestInterfacePointerType {
  "uniffi_bindings_tests::TestInterface"_ns,
  uniffi_uniffi_bindings_tests_fn_clone_testinterface,
  uniffi_uniffi_bindings_tests_fn_free_testinterface,
};
class FfiValueObjectHandleUniffiBindingsTestsTestInterface {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleUniffiBindingsTestsTestInterface() = default;
  explicit FfiValueObjectHandleUniffiBindingsTestsTestInterface(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleUniffiBindingsTestsTestInterface(const FfiValueObjectHandleUniffiBindingsTestsTestInterface&) = delete;
  FfiValueObjectHandleUniffiBindingsTestsTestInterface& operator=(const FfiValueObjectHandleUniffiBindingsTestsTestInterface&) = delete;

  FfiValueObjectHandleUniffiBindingsTestsTestInterface& operator=(FfiValueObjectHandleUniffiBindingsTestsTestInterface&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kUniffiBindingsTestsTestInterfacePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kUniffiBindingsTestsTestInterfacePointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleUniffiBindingsTestsTestInterface FromRust(uint64_t aValue) {
    return FfiValueObjectHandleUniffiBindingsTestsTestInterface(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_bindings_tests_fn_free_testinterface)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleUniffiBindingsTestsTestInterface() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kUniffiBindingsTestsAsyncInterfacePointerType {
  "uniffi_bindings_tests::AsyncInterface"_ns,
  uniffi_uniffi_bindings_tests_fn_clone_asyncinterface,
  uniffi_uniffi_bindings_tests_fn_free_asyncinterface,
};
class FfiValueObjectHandleUniffiBindingsTestsAsyncInterface {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface() = default;
  explicit FfiValueObjectHandleUniffiBindingsTestsAsyncInterface(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface(const FfiValueObjectHandleUniffiBindingsTestsAsyncInterface&) = delete;
  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface& operator=(const FfiValueObjectHandleUniffiBindingsTestsAsyncInterface&) = delete;

  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface& operator=(FfiValueObjectHandleUniffiBindingsTestsAsyncInterface&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kUniffiBindingsTestsAsyncInterfacePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kUniffiBindingsTestsAsyncInterfacePointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleUniffiBindingsTestsAsyncInterface FromRust(uint64_t aValue) {
    return FfiValueObjectHandleUniffiBindingsTestsAsyncInterface(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_bindings_tests_fn_free_asyncinterface)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleUniffiBindingsTestsAsyncInterface() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kUniffiBindingsTestsAsyncTestTraitInterfacePointerType {
  "uniffi_bindings_tests::AsyncTestTraitInterface"_ns,
  uniffi_uniffi_bindings_tests_fn_clone_asynctesttraitinterface,
  uniffi_uniffi_bindings_tests_fn_free_asynctesttraitinterface,
};
// Forward declare the free and clone functions, which are defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_uniffi_bindings_tests_async_test_trait_interface(uint64_t uniffiHandle);
extern "C" uint64_t callback_clone_uniffi_bindings_tests_async_test_trait_interface(uint64_t uniffiHandle);

// Trait interface FFI value class.  This is a hybrid between the one for interfaces and callback
// interface version
class FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface {
 private:
  // The raw FFI value is a uint64_t in all cases.
  // For callback interfaces, the uint64_t handle gets casted to a pointer.  Callback interface
  // handles are used as the uint64_t and are incremented by one at a time, so even on a 32-bit system this
  // shouldn't overflow.
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface() = default;
  explicit FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface(const FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface&) = delete;
  FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface& operator=(const FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface&) = delete;

  FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface& operator=(FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  // Lower a trait interface, `aValue` can either be a Rust or JS handle
  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    FreeHandle();
    if (aValue.IsUniFFIPointer()) {
      // Rust handle.  Clone the handle and return it.
      dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
      if (!value.IsSamePtrType(&kUniffiBindingsTestsAsyncTestTraitInterfacePointerType)) {
        aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
        return;
      }
      mValue = value.ClonePtr();
    } else if (aValue.IsDouble()) {
      // JS handle.  Just return it, the JS code has already incremented the
      // refcount
      double floatValue = aValue.GetAsDouble();
      uint64_t intValue = static_cast<uint64_t>(floatValue);
      if (intValue != floatValue) {
        aError.ThrowTypeError("Not an integer"_ns);
        return;
      }
      mValue = intValue;
    } else {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
  }

  // Lift a trait interface.  `mValue` can either by a Rust or JS handle
  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    if ((mValue & 1) == 0) {
      // Rust handle
      aDest->SetAsUniFFIPointer() =
          dom::UniFFIPointer::Create(mValue, &kUniffiBindingsTestsAsyncTestTraitInterfacePointerType);
    } else {
      // JS handle
      aDest->SetAsDouble() = mValue;
    }
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface FromRust(uint64_t aValue) {
    return FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface(aValue);
  }

  void FreeHandle() {
    // If we're storing a handle, call the free function for it. The function to
    // call depends on if we're holding a JS or Rust implementation of the
    // interface. We can tell that by looking at the lowest bit of the handle
    if (mValue == 0) {
      // 0 indicates we're not storing a handle.
    } else if ((mValue & 1) == 0) {
      // Rust implementation
      RustCallStatus callStatus{};
      (uniffi_uniffi_bindings_tests_fn_free_asynctesttraitinterface)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    } else {
      // JS implementation
      callback_free_uniffi_bindings_tests_async_test_trait_interface(mValue);
    }
    mValue = 0;
  }

  ~FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kUniffiBindingsTestsComplexMethodsPointerType {
  "uniffi_bindings_tests::ComplexMethods"_ns,
  uniffi_uniffi_bindings_tests_fn_clone_complexmethods,
  uniffi_uniffi_bindings_tests_fn_free_complexmethods,
};
class FfiValueObjectHandleUniffiBindingsTestsComplexMethods {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods() = default;
  explicit FfiValueObjectHandleUniffiBindingsTestsComplexMethods(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods(const FfiValueObjectHandleUniffiBindingsTestsComplexMethods&) = delete;
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods& operator=(const FfiValueObjectHandleUniffiBindingsTestsComplexMethods&) = delete;

  FfiValueObjectHandleUniffiBindingsTestsComplexMethods& operator=(FfiValueObjectHandleUniffiBindingsTestsComplexMethods&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kUniffiBindingsTestsComplexMethodsPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kUniffiBindingsTestsComplexMethodsPointerType);
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleUniffiBindingsTestsComplexMethods FromRust(uint64_t aValue) {
    return FfiValueObjectHandleUniffiBindingsTestsComplexMethods(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_bindings_tests_fn_free_complexmethods)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleUniffiBindingsTestsComplexMethods() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kUniffiBindingsTestsTestTraitInterfacePointerType {
  "uniffi_bindings_tests::TestTraitInterface"_ns,
  uniffi_uniffi_bindings_tests_fn_clone_testtraitinterface,
  uniffi_uniffi_bindings_tests_fn_free_testtraitinterface,
};
// Forward declare the free and clone functions, which are defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_uniffi_bindings_tests_test_trait_interface(uint64_t uniffiHandle);
extern "C" uint64_t callback_clone_uniffi_bindings_tests_test_trait_interface(uint64_t uniffiHandle);

// Trait interface FFI value class.  This is a hybrid between the one for interfaces and callback
// interface version
class FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface {
 private:
  // The raw FFI value is a uint64_t in all cases.
  // For callback interfaces, the uint64_t handle gets casted to a pointer.  Callback interface
  // handles are used as the uint64_t and are incremented by one at a time, so even on a 32-bit system this
  // shouldn't overflow.
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface() = default;
  explicit FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface(uint64_t aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface(const FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface&) = delete;
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface& operator=(const FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface&) = delete;

  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface& operator=(FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = 0;
    return *this;
  }

  // Lower a trait interface, `aValue` can either be a Rust or JS handle
  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    FreeHandle();
    if (aValue.IsUniFFIPointer()) {
      // Rust handle.  Clone the handle and return it.
      dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
      if (!value.IsSamePtrType(&kUniffiBindingsTestsTestTraitInterfacePointerType)) {
        aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
        return;
      }
      mValue = value.ClonePtr();
    } else if (aValue.IsDouble()) {
      // JS handle.  Just return it, the JS code has already incremented the
      // refcount
      double floatValue = aValue.GetAsDouble();
      uint64_t intValue = static_cast<uint64_t>(floatValue);
      if (intValue != floatValue) {
        aError.ThrowTypeError("Not an integer"_ns);
        return;
      }
      mValue = intValue;
    } else {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
  }

  // Lift a trait interface.  `mValue` can either by a Rust or JS handle
  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    if ((mValue & 1) == 0) {
      // Rust handle
      aDest->SetAsUniFFIPointer() =
          dom::UniFFIPointer::Create(mValue, &kUniffiBindingsTestsTestTraitInterfacePointerType);
    } else {
      // JS handle
      aDest->SetAsDouble() = mValue;
    }
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto temp = mValue;
    mValue = 0;
    return temp;
  }

  static FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface FromRust(uint64_t aValue) {
    return FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface(aValue);
  }

  void FreeHandle() {
    // If we're storing a handle, call the free function for it. The function to
    // call depends on if we're holding a JS or Rust implementation of the
    // interface. We can tell that by looking at the lowest bit of the handle
    if (mValue == 0) {
      // 0 indicates we're not storing a handle.
    } else if ((mValue & 1) == 0) {
      // Rust implementation
      RustCallStatus callStatus{};
      (uniffi_uniffi_bindings_tests_fn_free_testtraitinterface)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    } else {
      // JS implementation
      callback_free_uniffi_bindings_tests_test_trait_interface(mValue);
    }
    mValue = 0;
  }

  ~FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
#endif /* MOZ_UNIFFI_FIXTURES */

Maybe<already_AddRefed<UniFFIPointer>> ReadPointer(const GlobalObject& aGlobal, uint64_t aId, const ArrayBuffer& aArrayBuff, long aPosition, ErrorResult& aError) {
  const UniFFIPointerType* type;
  switch (aId) {

    case 1: {
      type = &kContextIdContextIdComponentPointerType;
      break;
    }
    case 2: {
      type = &kFilterAdultFilterAdultComponentPointerType;
      break;
    }
    case 3: {
      type = &kLoginsEncryptorDecryptorPointerType;
      break;
    }
    case 4: {
      type = &kLoginsKeyManagerPointerType;
      break;
    }
    case 5: {
      type = &kLoginsLoginStorePointerType;
      break;
    }
    case 6: {
      type = &kLoginsManagedEncryptorDecryptorPointerType;
      break;
    }
    case 7: {
      type = &kLoginsNssKeyManagerPointerType;
      break;
    }
    case 8: {
      type = &kLoginsPrimaryPasswordAuthenticatorPointerType;
      break;
    }
    case 9: {
      type = &kLoginsStaticKeyManagerPointerType;
      break;
    }
    case 10: {
      type = &kRelevancyRelevancyStorePointerType;
      break;
    }
    case 11: {
      type = &kRemoteSettingsRemoteSettingsPointerType;
      break;
    }
    case 12: {
      type = &kRemoteSettingsRemoteSettingsClientPointerType;
      break;
    }
    case 13: {
      type = &kRemoteSettingsRemoteSettingsServicePointerType;
      break;
    }
    case 14: {
      type = &kSearchSearchEngineSelectorPointerType;
      break;
    }
    case 15: {
      type = &kSuggestSuggestStorePointerType;
      break;
    }
    case 16: {
      type = &kSuggestSuggestStoreBuilderPointerType;
      break;
    }
    case 17: {
      type = &kTabsRemoteCommandStorePointerType;
      break;
    }
    case 18: {
      type = &kTabsTabsBridgedEnginePointerType;
      break;
    }
    case 19: {
      type = &kTabsTabsStorePointerType;
      break;
    }
    case 20: {
      type = &kViaductBackendPointerType;
      break;
    }
    case 21: {
      type = &kWebextstorageWebExtStorageBridgedEnginePointerType;
      break;
    }
    case 22: {
      type = &kWebextstorageWebExtStorageStorePointerType;
      break;
    }

#ifdef MOZ_UNIFFI_FIXTURES
    case 23: {
      type = &kUniffiBindingsTestsTestInterfacePointerType;
      break;
    }
    case 24: {
      type = &kUniffiBindingsTestsAsyncInterfacePointerType;
      break;
    }
    case 25: {
      type = &kUniffiBindingsTestsAsyncTestTraitInterfacePointerType;
      break;
    }
    case 26: {
      type = &kUniffiBindingsTestsComplexMethodsPointerType;
      break;
    }
    case 27: {
      type = &kUniffiBindingsTestsTestTraitInterfacePointerType;
      break;
    }
#endif /* MOZ_UNIFFI_FIXTURES */
    default:
      return Nothing();
  }
  return Some(UniFFIPointer::Read(aArrayBuff, aPosition, type, aError));
}

bool WritePointer(const GlobalObject& aGlobal, uint64_t aId, const UniFFIPointer& aPtr, const ArrayBuffer& aArrayBuff, long aPosition, ErrorResult& aError) {
  const UniFFIPointerType* type;
  switch (aId) {

    case 1: {
      type = &kContextIdContextIdComponentPointerType;
      break;
    }
    case 2: {
      type = &kFilterAdultFilterAdultComponentPointerType;
      break;
    }
    case 3: {
      type = &kLoginsEncryptorDecryptorPointerType;
      break;
    }
    case 4: {
      type = &kLoginsKeyManagerPointerType;
      break;
    }
    case 5: {
      type = &kLoginsLoginStorePointerType;
      break;
    }
    case 6: {
      type = &kLoginsManagedEncryptorDecryptorPointerType;
      break;
    }
    case 7: {
      type = &kLoginsNssKeyManagerPointerType;
      break;
    }
    case 8: {
      type = &kLoginsPrimaryPasswordAuthenticatorPointerType;
      break;
    }
    case 9: {
      type = &kLoginsStaticKeyManagerPointerType;
      break;
    }
    case 10: {
      type = &kRelevancyRelevancyStorePointerType;
      break;
    }
    case 11: {
      type = &kRemoteSettingsRemoteSettingsPointerType;
      break;
    }
    case 12: {
      type = &kRemoteSettingsRemoteSettingsClientPointerType;
      break;
    }
    case 13: {
      type = &kRemoteSettingsRemoteSettingsServicePointerType;
      break;
    }
    case 14: {
      type = &kSearchSearchEngineSelectorPointerType;
      break;
    }
    case 15: {
      type = &kSuggestSuggestStorePointerType;
      break;
    }
    case 16: {
      type = &kSuggestSuggestStoreBuilderPointerType;
      break;
    }
    case 17: {
      type = &kTabsRemoteCommandStorePointerType;
      break;
    }
    case 18: {
      type = &kTabsTabsBridgedEnginePointerType;
      break;
    }
    case 19: {
      type = &kTabsTabsStorePointerType;
      break;
    }
    case 20: {
      type = &kViaductBackendPointerType;
      break;
    }
    case 21: {
      type = &kWebextstorageWebExtStorageBridgedEnginePointerType;
      break;
    }
    case 22: {
      type = &kWebextstorageWebExtStorageStorePointerType;
      break;
    }

#ifdef MOZ_UNIFFI_FIXTURES
    case 23: {
      type = &kUniffiBindingsTestsTestInterfacePointerType;
      break;
    }
    case 24: {
      type = &kUniffiBindingsTestsAsyncInterfacePointerType;
      break;
    }
    case 25: {
      type = &kUniffiBindingsTestsAsyncTestTraitInterfacePointerType;
      break;
    }
    case 26: {
      type = &kUniffiBindingsTestsComplexMethodsPointerType;
      break;
    }
    case 27: {
      type = &kUniffiBindingsTestsTestTraitInterfacePointerType;
      break;
    }
#endif /* MOZ_UNIFFI_FIXTURES */
    default:
      return false;
  }
  aPtr.Write(aArrayBuff, aPosition, type, aError);
  return true;
}
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


// Callback interface FfiValueClasses
//
// These need to come first so they're defined for the scaffolding call code


// Forward declare the free function, which is defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_context_id_context_id_callback(uint64_t uniffiHandle);

// FfiValue class for these callback interface handles.  This works like the
// `FfiValueInt<uint64_t>`, except it has extra code to cleanup the callback handles.
class FfiValueObjectHandleContextIdContextIdCallback {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleContextIdContextIdCallback() = default;
  explicit FfiValueObjectHandleContextIdContextIdCallback(uint64_t aValue) : mValue(aValue) {}

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsDouble()) {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
    double floatValue = aValue.GetAsDouble();

    uint64_t intValue = static_cast<uint64_t>(floatValue);
    if (intValue != floatValue) {
      aError.ThrowTypeError("Not an integer"_ns);
      return;
    }
    ReleaseHandleIfSet();
    mValue = intValue;
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsDouble() = mValue;
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto handle = mValue;
    mValue = 0;
    return handle;
  }

  static FfiValueObjectHandleContextIdContextIdCallback FromRust(uint64_t aValue) { return FfiValueObjectHandleContextIdContextIdCallback(aValue); };

  void ReleaseHandleIfSet() {
    // A non-zero value indicates that we own a callback handle that was never passed to Rust or
    // lifted to JS.  Call the free function to decrease the refcount.
    if (mValue != 0) {
        callback_free_context_id_context_id_callback(mValue);
        mValue = 0;
    }
  }

  ~FfiValueObjectHandleContextIdContextIdCallback() {
    ReleaseHandleIfSet();
  }
};

// Forward declare the free function, which is defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_tracing_event_sink(uint64_t uniffiHandle);

// FfiValue class for these callback interface handles.  This works like the
// `FfiValueInt<uint64_t>`, except it has extra code to cleanup the callback handles.
class FfiValueObjectHandleTracingEventSink {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleTracingEventSink() = default;
  explicit FfiValueObjectHandleTracingEventSink(uint64_t aValue) : mValue(aValue) {}

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsDouble()) {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
    double floatValue = aValue.GetAsDouble();

    uint64_t intValue = static_cast<uint64_t>(floatValue);
    if (intValue != floatValue) {
      aError.ThrowTypeError("Not an integer"_ns);
      return;
    }
    ReleaseHandleIfSet();
    mValue = intValue;
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsDouble() = mValue;
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto handle = mValue;
    mValue = 0;
    return handle;
  }

  static FfiValueObjectHandleTracingEventSink FromRust(uint64_t aValue) { return FfiValueObjectHandleTracingEventSink(aValue); };

  void ReleaseHandleIfSet() {
    // A non-zero value indicates that we own a callback handle that was never passed to Rust or
    // lifted to JS.  Call the free function to decrease the refcount.
    if (mValue != 0) {
        callback_free_tracing_event_sink(mValue);
        mValue = 0;
    }
  }

  ~FfiValueObjectHandleTracingEventSink() {
    ReleaseHandleIfSet();
  }
};

#ifdef MOZ_UNIFFI_FIXTURES

// Forward declare the free function, which is defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_uniffi_bindings_tests_test_async_callback_interface(uint64_t uniffiHandle);

// FfiValue class for these callback interface handles.  This works like the
// `FfiValueInt<uint64_t>`, except it has extra code to cleanup the callback handles.
class FfiValueObjectHandleUniffiBindingsTestsTestAsyncCallbackInterface {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleUniffiBindingsTestsTestAsyncCallbackInterface() = default;
  explicit FfiValueObjectHandleUniffiBindingsTestsTestAsyncCallbackInterface(uint64_t aValue) : mValue(aValue) {}

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsDouble()) {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
    double floatValue = aValue.GetAsDouble();

    uint64_t intValue = static_cast<uint64_t>(floatValue);
    if (intValue != floatValue) {
      aError.ThrowTypeError("Not an integer"_ns);
      return;
    }
    ReleaseHandleIfSet();
    mValue = intValue;
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsDouble() = mValue;
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto handle = mValue;
    mValue = 0;
    return handle;
  }

  static FfiValueObjectHandleUniffiBindingsTestsTestAsyncCallbackInterface FromRust(uint64_t aValue) { return FfiValueObjectHandleUniffiBindingsTestsTestAsyncCallbackInterface(aValue); };

  void ReleaseHandleIfSet() {
    // A non-zero value indicates that we own a callback handle that was never passed to Rust or
    // lifted to JS.  Call the free function to decrease the refcount.
    if (mValue != 0) {
        callback_free_uniffi_bindings_tests_test_async_callback_interface(mValue);
        mValue = 0;
    }
  }

  ~FfiValueObjectHandleUniffiBindingsTestsTestAsyncCallbackInterface() {
    ReleaseHandleIfSet();
  }
};

// Forward declare the free function, which is defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_uniffi_bindings_tests_test_callback_interface(uint64_t uniffiHandle);

// FfiValue class for these callback interface handles.  This works like the
// `FfiValueInt<uint64_t>`, except it has extra code to cleanup the callback handles.
class FfiValueObjectHandleUniffiBindingsTestsTestCallbackInterface {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleUniffiBindingsTestsTestCallbackInterface() = default;
  explicit FfiValueObjectHandleUniffiBindingsTestsTestCallbackInterface(uint64_t aValue) : mValue(aValue) {}

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsDouble()) {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
    double floatValue = aValue.GetAsDouble();

    uint64_t intValue = static_cast<uint64_t>(floatValue);
    if (intValue != floatValue) {
      aError.ThrowTypeError("Not an integer"_ns);
      return;
    }
    ReleaseHandleIfSet();
    mValue = intValue;
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsDouble() = mValue;
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto handle = mValue;
    mValue = 0;
    return handle;
  }

  static FfiValueObjectHandleUniffiBindingsTestsTestCallbackInterface FromRust(uint64_t aValue) { return FfiValueObjectHandleUniffiBindingsTestsTestCallbackInterface(aValue); };

  void ReleaseHandleIfSet() {
    // A non-zero value indicates that we own a callback handle that was never passed to Rust or
    // lifted to JS.  Call the free function to decrease the refcount.
    if (mValue != 0) {
        callback_free_uniffi_bindings_tests_test_callback_interface(mValue);
        mValue = 0;
    }
  }

  ~FfiValueObjectHandleUniffiBindingsTestsTestCallbackInterface() {
    ReleaseHandleIfSet();
  }
};

// Forward declare the free function, which is defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_uniffi_bindings_tests_collision_test_callback_interface(uint64_t uniffiHandle);

// FfiValue class for these callback interface handles.  This works like the
// `FfiValueInt<uint64_t>`, except it has extra code to cleanup the callback handles.
class FfiValueObjectHandleUniffiBindingsTestsCollisionTestCallbackInterface {
 private:
  uint64_t mValue = 0;

 public:
  FfiValueObjectHandleUniffiBindingsTestsCollisionTestCallbackInterface() = default;
  explicit FfiValueObjectHandleUniffiBindingsTestsCollisionTestCallbackInterface(uint64_t aValue) : mValue(aValue) {}

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsDouble()) {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
    double floatValue = aValue.GetAsDouble();

    uint64_t intValue = static_cast<uint64_t>(floatValue);
    if (intValue != floatValue) {
      aError.ThrowTypeError("Not an integer"_ns);
      return;
    }
    ReleaseHandleIfSet();
    mValue = intValue;
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsDouble() = mValue;
    mValue = 0;
  }

  uint64_t IntoRust() {
    auto handle = mValue;
    mValue = 0;
    return handle;
  }

  static FfiValueObjectHandleUniffiBindingsTestsCollisionTestCallbackInterface FromRust(uint64_t aValue) { return FfiValueObjectHandleUniffiBindingsTestsCollisionTestCallbackInterface(aValue); };

  void ReleaseHandleIfSet() {
    // A non-zero value indicates that we own a callback handle that was never passed to Rust or
    // lifted to JS.  Call the free function to decrease the refcount.
    if (mValue != 0) {
        callback_free_uniffi_bindings_tests_collision_test_callback_interface(mValue);
        mValue = 0;
    }
  }

  ~FfiValueObjectHandleUniffiBindingsTestsCollisionTestCallbackInterface() {
    ReleaseHandleIfSet();
  }
};
#endif /* MOZ_UNIFFI_FIXTURES */
/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

// Define scaffolding call classes for each combination of return/argument types

class ScaffoldingCallHandlerUniffiContextIdFnConstructorContextidcomponentNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mInitContextId{};
  FfiValueInt<int64_t> mCreationTimestampS{};
  FfiValueInt<int8_t> mRunningInTestAutomation{};
  FfiValueObjectHandleContextIdContextIdCallback mCallback{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleContextIdContextIdComponent mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 4) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_context_id_fn_constructor_contextidcomponent_new (expected: 4, actual: %zu)", aArgs.Length()));
      return;
    }
    mInitContextId.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCreationTimestampS.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mRunningInTestAutomation.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mCallback.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleContextIdContextIdComponent::FromRust(
      uniffi_context_id_fn_constructor_contextidcomponent_new(
        mInitContextId.IntoRust(),
        mCreationTimestampS.IntoRust(),
        mRunningInTestAutomation.IntoRust(),
        mCallback.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentForceRotation : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleContextIdContextIdComponent mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_context_id_fn_method_contextidcomponent_force_rotation (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_context_id_fn_method_contextidcomponent_force_rotation(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentRequest : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleContextIdContextIdComponent mUniffiPtr{};
  FfiValueInt<uint8_t> mRotationDaysInS{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_context_id_fn_method_contextidcomponent_request (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRotationDaysInS.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_context_id_fn_method_contextidcomponent_request(
        mUniffiPtr.IntoRust(),
        mRotationDaysInS.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentUnsetCallback : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleContextIdContextIdComponent mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_context_id_fn_method_contextidcomponent_unset_callback (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_context_id_fn_method_contextidcomponent_unset_callback(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiFilterAdultFnConstructorFilteradultcomponentNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleFilterAdultFilterAdultComponent mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleFilterAdultFilterAdultComponent::FromRust(
      uniffi_filter_adult_fn_constructor_filteradultcomponent_new(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiFilterAdultFnMethodFilteradultcomponentContains : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleFilterAdultFilterAdultComponent mUniffiPtr{};
  FfiValueRustBuffer mBaseDomainToCheck{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_filter_adult_fn_method_filteradultcomponent_contains (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBaseDomainToCheck.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_filter_adult_fn_method_filteradultcomponent_contains(
        mUniffiPtr.IntoRust(),
        mBaseDomainToCheck.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiInitRustComponentsFnFuncInitialize : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mProfilePath{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_init_rust_components_fn_func_initialize (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mProfilePath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_init_rust_components_fn_func_initialize(
      mProfilePath.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnFuncCheckCanary : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mCanary{};
  FfiValueRustBuffer mText{};
  FfiValueRustBuffer mEncryptionKey{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_func_check_canary (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mCanary.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mText.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mEncryptionKey.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_logins_fn_func_check_canary(
        mCanary.IntoRust(),
        mText.IntoRust(),
        mEncryptionKey.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnFuncCreateCanary : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mText{};
  FfiValueRustBuffer mEncryptionKey{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_func_create_canary (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mText.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mEncryptionKey.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_func_create_canary(
        mText.IntoRust(),
        mEncryptionKey.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnFuncCreateKey : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_func_create_key(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnFuncCreateLoginStoreWithNssKeymanager : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mPath{};
  FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator mPrimaryPasswordAuthenticator{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_func_create_login_store_with_nss_keymanager (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mPrimaryPasswordAuthenticator.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleLoginsLoginStore::FromRust(
      uniffi_logins_fn_func_create_login_store_with_nss_keymanager(
        mPath.IntoRust(),
        mPrimaryPasswordAuthenticator.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnFuncCreateLoginStoreWithStaticKeyManager : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mPath{};
  FfiValueRustBuffer mKey{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_func_create_login_store_with_static_key_manager (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mKey.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleLoginsLoginStore::FromRust(
      uniffi_logins_fn_func_create_login_store_with_static_key_manager(
        mPath.IntoRust(),
        mKey.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnFuncCreateManagedEncdec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsKeyManager mKeyManager{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleLoginsEncryptorDecryptor mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_func_create_managed_encdec (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mKeyManager.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleLoginsEncryptorDecryptor::FromRust(
      uniffi_logins_fn_func_create_managed_encdec(
        mKeyManager.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnFuncCreateStaticKeyManager : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mKey{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleLoginsKeyManager mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_func_create_static_key_manager (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mKey.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleLoginsKeyManager::FromRust(
      uniffi_logins_fn_func_create_static_key_manager(
        mKey.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodEncryptordecryptorDecrypt : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsEncryptorDecryptor mUniffiPtr{};
  FfiValueRustBuffer mCiphertext{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_encryptordecryptor_decrypt (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCiphertext.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_encryptordecryptor_decrypt(
        mUniffiPtr.IntoRust(),
        mCiphertext.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodEncryptordecryptorEncrypt : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsEncryptorDecryptor mUniffiPtr{};
  FfiValueRustBuffer mCleartext{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_encryptordecryptor_encrypt (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCleartext.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_encryptordecryptor_encrypt(
        mUniffiPtr.IntoRust(),
        mCleartext.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodKeymanagerGetKey : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsKeyManager mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_keymanager_get_key (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_keymanager_get_key(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnConstructorLoginstoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mPath{};
  FfiValueObjectHandleLoginsEncryptorDecryptor mEncdec{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_constructor_loginstore_new (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mEncdec.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleLoginsLoginStore::FromRust(
      uniffi_logins_fn_constructor_loginstore_new(
        mPath.IntoRust(),
        mEncdec.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreAdd : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mLogin{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_add (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLogin.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_loginstore_add(
        mUniffiPtr.IntoRust(),
        mLogin.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreAddMany : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mLogins{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_add_many (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLogins.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_loginstore_add_many(
        mUniffiPtr.IntoRust(),
        mLogins.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreAddManyWithMeta : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mEntriesWithMeta{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_add_many_with_meta (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mEntriesWithMeta.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_loginstore_add_many_with_meta(
        mUniffiPtr.IntoRust(),
        mEntriesWithMeta.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreAddOrUpdate : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mLogin{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_add_or_update (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLogin.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_loginstore_add_or_update(
        mUniffiPtr.IntoRust(),
        mLogin.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreAddWithMeta : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mEntryWithMeta{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_add_with_meta (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mEntryWithMeta.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_loginstore_add_with_meta(
        mUniffiPtr.IntoRust(),
        mEntryWithMeta.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreArePotentiallyVulnerablePasswords : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mIds{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_are_potentially_vulnerable_passwords (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mIds.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_loginstore_are_potentially_vulnerable_passwords(
        mUniffiPtr.IntoRust(),
        mIds.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreCount : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_count (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_logins_fn_method_loginstore_count(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreCountByFormActionOrigin : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mFormActionOrigin{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_count_by_form_action_origin (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mFormActionOrigin.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_logins_fn_method_loginstore_count_by_form_action_origin(
        mUniffiPtr.IntoRust(),
        mFormActionOrigin.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreCountByOrigin : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mOrigin{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_count_by_origin (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mOrigin.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_logins_fn_method_loginstore_count_by_origin(
        mUniffiPtr.IntoRust(),
        mOrigin.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreDelete : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_delete (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_logins_fn_method_loginstore_delete(
        mUniffiPtr.IntoRust(),
        mId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreDeleteMany : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mIds{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_delete_many (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mIds.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_loginstore_delete_many(
        mUniffiPtr.IntoRust(),
        mIds.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreDeleteUndecryptableRecordsForRemoteReplacement : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_delete_undecryptable_records_for_remote_replacement (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_loginstore_delete_undecryptable_records_for_remote_replacement(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreFindLoginToUpdate : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mLook{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_find_login_to_update (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLook.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_loginstore_find_login_to_update(
        mUniffiPtr.IntoRust(),
        mLook.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreGet : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_get (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_loginstore_get(
        mUniffiPtr.IntoRust(),
        mId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreGetByBaseDomain : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mBaseDomain{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_get_by_base_domain (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBaseDomain.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_loginstore_get_by_base_domain(
        mUniffiPtr.IntoRust(),
        mBaseDomain.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreGetCheckpoint : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_get_checkpoint (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_loginstore_get_checkpoint(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreHasLoginsByBaseDomain : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mBaseDomain{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_has_logins_by_base_domain (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBaseDomain.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_logins_fn_method_loginstore_has_logins_by_base_domain(
        mUniffiPtr.IntoRust(),
        mBaseDomain.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreIsBreachAlertDismissed : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_is_breach_alert_dismissed (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_logins_fn_method_loginstore_is_breach_alert_dismissed(
        mUniffiPtr.IntoRust(),
        mId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreIsEmpty : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_is_empty (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_logins_fn_method_loginstore_is_empty(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreIsPotentiallyBreached : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_is_potentially_breached (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_logins_fn_method_loginstore_is_potentially_breached(
        mUniffiPtr.IntoRust(),
        mId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreIsPotentiallyVulnerablePassword : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_is_potentially_vulnerable_password (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_logins_fn_method_loginstore_is_potentially_vulnerable_password(
        mUniffiPtr.IntoRust(),
        mId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreList : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_list (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_loginstore_list(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreRecordBreach : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mId{};
  FfiValueInt<int64_t> mTimestamp{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_record_breach (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mTimestamp.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_logins_fn_method_loginstore_record_breach(
      mUniffiPtr.IntoRust(),
      mId.IntoRust(),
      mTimestamp.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreRecordBreachAlertDismissal : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mId{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_record_breach_alert_dismissal (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_logins_fn_method_loginstore_record_breach_alert_dismissal(
      mUniffiPtr.IntoRust(),
      mId.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreRecordBreachAlertDismissalTime : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mId{};
  FfiValueInt<int64_t> mTimestamp{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_record_breach_alert_dismissal_time (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mTimestamp.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_logins_fn_method_loginstore_record_breach_alert_dismissal_time(
      mUniffiPtr.IntoRust(),
      mId.IntoRust(),
      mTimestamp.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreRecordPotentiallyVulnerablePasswords : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mPasswords{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_record_potentially_vulnerable_passwords (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mPasswords.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_logins_fn_method_loginstore_record_potentially_vulnerable_passwords(
      mUniffiPtr.IntoRust(),
      mPasswords.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreRegisterWithSyncManager : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_register_with_sync_manager (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_logins_fn_method_loginstore_register_with_sync_manager(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreReset : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_reset (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_logins_fn_method_loginstore_reset(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreResetAllBreaches : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_reset_all_breaches (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_logins_fn_method_loginstore_reset_all_breaches(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreRunMaintenance : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_run_maintenance (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_logins_fn_method_loginstore_run_maintenance(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreSetCheckpoint : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mCheckpoint{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_set_checkpoint (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCheckpoint.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_logins_fn_method_loginstore_set_checkpoint(
      mUniffiPtr.IntoRust(),
      mCheckpoint.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreShutdown : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_shutdown (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_logins_fn_method_loginstore_shutdown(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreTouch : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mId{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_touch (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_logins_fn_method_loginstore_touch(
      mUniffiPtr.IntoRust(),
      mId.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreUpdate : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};
  FfiValueRustBuffer mId{};
  FfiValueRustBuffer mLogin{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_update (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mLogin.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_logins_fn_method_loginstore_update(
        mUniffiPtr.IntoRust(),
        mId.IntoRust(),
        mLogin.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreWipeLocal : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsLoginStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_loginstore_wipe_local (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_logins_fn_method_loginstore_wipe_local(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnConstructorManagedencryptordecryptorNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsKeyManager mKeyManager{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleLoginsManagedEncryptorDecryptor mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_constructor_managedencryptordecryptor_new (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mKeyManager.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleLoginsManagedEncryptorDecryptor::FromRust(
      uniffi_logins_fn_constructor_managedencryptordecryptor_new(
        mKeyManager.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnConstructorNsskeymanagerNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator mPrimaryPasswordAuthenticator{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleLoginsNssKeyManager mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_constructor_nsskeymanager_new (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mPrimaryPasswordAuthenticator.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleLoginsNssKeyManager::FromRust(
      uniffi_logins_fn_constructor_nsskeymanager_new(
        mPrimaryPasswordAuthenticator.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodNsskeymanagerIntoDynKeyManager : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleLoginsNssKeyManager mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleLoginsKeyManager mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_method_nsskeymanager_into_dyn_key_manager (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleLoginsKeyManager::FromRust(
      uniffi_logins_fn_method_nsskeymanager_into_dyn_key_manager(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodPrimarypasswordauthenticatorGetPrimaryPassword : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiLoginsFnMethodPrimarypasswordauthenticatorGetPrimaryPassword() : UniffiAsyncCallHandler(
        ffi_logins_rust_future_poll_rust_buffer,
        ffi_logins_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator mUniffiPtr{};
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_logins_fn_method_primarypasswordauthenticator_get_primary_password(
      mUniffiPtr.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_logins_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodPrimarypasswordauthenticatorOnAuthenticationSuccess : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiLoginsFnMethodPrimarypasswordauthenticatorOnAuthenticationSuccess() : UniffiAsyncCallHandler(
        ffi_logins_rust_future_poll_void,
        ffi_logins_rust_future_free_void
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator mUniffiPtr{};
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_logins_fn_method_primarypasswordauthenticator_on_authentication_success(
      mUniffiPtr.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    ffi_logins_rust_future_complete_void(mFutureHandle, aOutStatus);
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnMethodPrimarypasswordauthenticatorOnAuthenticationFailure : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiLoginsFnMethodPrimarypasswordauthenticatorOnAuthenticationFailure() : UniffiAsyncCallHandler(
        ffi_logins_rust_future_poll_void,
        ffi_logins_rust_future_free_void
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleLoginsPrimaryPasswordAuthenticator mUniffiPtr{};
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_logins_fn_method_primarypasswordauthenticator_on_authentication_failure(
      mUniffiPtr.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    ffi_logins_rust_future_complete_void(mFutureHandle, aOutStatus);
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiLoginsFnConstructorStatickeymanagerNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mKey{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleLoginsStaticKeyManager mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_logins_fn_constructor_statickeymanager_new (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mKey.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleLoginsStaticKeyManager::FromRust(
      uniffi_logins_fn_constructor_statickeymanager_new(
        mKey.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnFuncScore : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mInterestVector{};
  FfiValueRustBuffer mContentCategories{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<double> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_relevancy_fn_func_score (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mInterestVector.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mContentCategories.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      uniffi_relevancy_fn_func_score(
        mInterestVector.IntoRust(),
        mContentCategories.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnConstructorRelevancystoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mDbPath{};
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mRemoteSettings{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_relevancy_fn_constructor_relevancystore_new (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mDbPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRemoteSettings.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRelevancyRelevancyStore::FromRust(
      uniffi_relevancy_fn_constructor_relevancystore_new(
        mDbPath.IntoRust(),
        mRemoteSettings.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditInit : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};
  FfiValueRustBuffer mBandit{};
  FfiValueRustBuffer mArms{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_relevancy_fn_method_relevancystore_bandit_init (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBandit.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mArms.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_bandit_init(
      mUniffiPtr.IntoRust(),
      mBandit.IntoRust(),
      mArms.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditSelect : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};
  FfiValueRustBuffer mBandit{};
  FfiValueRustBuffer mArms{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_relevancy_fn_method_relevancystore_bandit_select (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBandit.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mArms.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_relevancy_fn_method_relevancystore_bandit_select(
        mUniffiPtr.IntoRust(),
        mBandit.IntoRust(),
        mArms.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditUpdate : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};
  FfiValueRustBuffer mBandit{};
  FfiValueRustBuffer mArm{};
  FfiValueInt<int8_t> mSelected{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 4) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_relevancy_fn_method_relevancystore_bandit_update (expected: 4, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBandit.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mArm.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mSelected.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_bandit_update(
      mUniffiPtr.IntoRust(),
      mBandit.IntoRust(),
      mArm.IntoRust(),
      mSelected.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreClose : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_relevancy_fn_method_relevancystore_close (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_close(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreEnsureInterestDataPopulated : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_relevancy_fn_method_relevancystore_ensure_interest_data_populated (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_ensure_interest_data_populated(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreGetBanditData : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};
  FfiValueRustBuffer mBandit{};
  FfiValueRustBuffer mArm{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_relevancy_fn_method_relevancystore_get_bandit_data (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBandit.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mArm.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_relevancy_fn_method_relevancystore_get_bandit_data(
        mUniffiPtr.IntoRust(),
        mBandit.IntoRust(),
        mArm.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreIngest : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};
  FfiValueRustBuffer mTopUrlsByFrecency{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_relevancy_fn_method_relevancystore_ingest (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mTopUrlsByFrecency.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_relevancy_fn_method_relevancystore_ingest(
        mUniffiPtr.IntoRust(),
        mTopUrlsByFrecency.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreInterrupt : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_relevancy_fn_method_relevancystore_interrupt (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_interrupt(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreUserInterestVector : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_relevancy_fn_method_relevancystore_user_interest_vector (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_relevancy_fn_method_relevancystore_user_interest_vector(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnConstructorRemotesettingsNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRemoteSettingsConfig{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettings mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_remote_settings_fn_constructor_remotesettings_new (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mRemoteSettingsConfig.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRemoteSettingsRemoteSettings::FromRust(
      uniffi_remote_settings_fn_constructor_remotesettings_new(
        mRemoteSettingsConfig.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsDownloadAttachmentToPath : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettings mUniffiPtr{};
  FfiValueRustBuffer mAttachmentId{};
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_remote_settings_fn_method_remotesettings_download_attachment_to_path (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mAttachmentId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mPath.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_remote_settings_fn_method_remotesettings_download_attachment_to_path(
      mUniffiPtr.IntoRust(),
      mAttachmentId.IntoRust(),
      mPath.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsGetRecords : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettings mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_remote_settings_fn_method_remotesettings_get_records (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettings_get_records(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsGetRecordsSince : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettings mUniffiPtr{};
  FfiValueInt<uint64_t> mTimestamp{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_remote_settings_fn_method_remotesettings_get_records_since (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mTimestamp.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettings_get_records_since(
        mUniffiPtr.IntoRust(),
        mTimestamp.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientCollectionName : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_remote_settings_fn_method_remotesettingsclient_collection_name (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsclient_collection_name(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetAttachment : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};
  FfiValueRustBuffer mRecord{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_remote_settings_fn_method_remotesettingsclient_get_attachment (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRecord.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsclient_get_attachment(
        mUniffiPtr.IntoRust(),
        mRecord.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetRecords : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};
  FfiValueInt<int8_t> mSyncIfEmpty{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_remote_settings_fn_method_remotesettingsclient_get_records (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSyncIfEmpty.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsclient_get_records(
        mUniffiPtr.IntoRust(),
        mSyncIfEmpty.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetRecordsMap : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};
  FfiValueInt<int8_t> mSyncIfEmpty{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_remote_settings_fn_method_remotesettingsclient_get_records_map (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSyncIfEmpty.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsclient_get_records_map(
        mUniffiPtr.IntoRust(),
        mSyncIfEmpty.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientShutdown : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_remote_settings_fn_method_remotesettingsclient_shutdown (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_remote_settings_fn_method_remotesettingsclient_shutdown(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_remote_settings_fn_method_remotesettingsclient_sync (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_remote_settings_fn_method_remotesettingsclient_sync(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnConstructorRemotesettingsserviceNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mStorageDir{};
  FfiValueRustBuffer mConfig{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_remote_settings_fn_constructor_remotesettingsservice_new (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mStorageDir.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mConfig.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRemoteSettingsRemoteSettingsService::FromRust(
      uniffi_remote_settings_fn_constructor_remotesettingsservice_new(
        mStorageDir.IntoRust(),
        mConfig.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceClientUrl : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_remote_settings_fn_method_remotesettingsservice_client_url (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsservice_client_url(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceMakeClient : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mUniffiPtr{};
  FfiValueRustBuffer mCollectionName{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_remote_settings_fn_method_remotesettingsservice_make_client (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCollectionName.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRemoteSettingsRemoteSettingsClient::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsservice_make_client(
        mUniffiPtr.IntoRust(),
        mCollectionName.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_remote_settings_fn_method_remotesettingsservice_sync (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsservice_sync(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceUpdateConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mUniffiPtr{};
  FfiValueRustBuffer mConfig{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_remote_settings_fn_method_remotesettingsservice_update_config (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mConfig.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_remote_settings_fn_method_remotesettingsservice_update_config(
      mUniffiPtr.IntoRust(),
      mConfig.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSearchFnConstructorSearchengineselectorNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSearchSearchEngineSelector::FromRust(
      uniffi_search_fn_constructor_searchengineselector_new(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorClearSearchConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_search_fn_method_searchengineselector_clear_search_config (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_search_fn_method_searchengineselector_clear_search_config(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorFilterEngineConfiguration : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiPtr{};
  FfiValueRustBuffer mUserEnvironment{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_search_fn_method_searchengineselector_filter_engine_configuration (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mUserEnvironment.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_search_fn_method_searchengineselector_filter_engine_configuration(
        mUniffiPtr.IntoRust(),
        mUserEnvironment.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorSetConfigOverrides : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiPtr{};
  FfiValueRustBuffer mOverrides{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_search_fn_method_searchengineselector_set_config_overrides (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mOverrides.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_search_fn_method_searchengineselector_set_config_overrides(
      mUniffiPtr.IntoRust(),
      mOverrides.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorSetSearchConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiPtr{};
  FfiValueRustBuffer mConfiguration{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_search_fn_method_searchengineselector_set_search_config (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mConfiguration.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_search_fn_method_searchengineselector_set_search_config(
      mUniffiPtr.IntoRust(),
      mConfiguration.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorUseRemoteSettingsServer : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiPtr{};
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mService{};
  FfiValueInt<int8_t> mApplyEngineOverrides{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_search_fn_method_searchengineselector_use_remote_settings_server (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mService.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mApplyEngineOverrides.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_search_fn_method_searchengineselector_use_remote_settings_server(
      mUniffiPtr.IntoRust(),
      mService.IntoRust(),
      mApplyEngineOverrides.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnFuncRawSuggestionUrlMatches : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRawUrl{};
  FfiValueRustBuffer mCookedUrl{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_func_raw_suggestion_url_matches (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mRawUrl.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCookedUrl.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_suggest_fn_func_raw_suggestion_url_matches(
        mRawUrl.IntoRust(),
        mCookedUrl.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnConstructorSuggeststoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mPath{};
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mRemoteSettingsService{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_constructor_suggeststore_new (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRemoteSettingsService.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStore::FromRust(
      uniffi_suggest_fn_constructor_suggeststore_new(
        mPath.IntoRust(),
        mRemoteSettingsService.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreAnyDismissedSuggestions : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststore_any_dismissed_suggestions (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_suggest_fn_method_suggeststore_any_dismissed_suggestions(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreClear : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststore_clear (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_clear(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreClearDismissedSuggestions : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststore_clear_dismissed_suggestions (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_clear_dismissed_suggestions(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissByKey : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mKey{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststore_dismiss_by_key (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mKey.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_dismiss_by_key(
      mUniffiPtr.IntoRust(),
      mKey.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissBySuggestion : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mSuggestion{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststore_dismiss_by_suggestion (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSuggestion.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_dismiss_by_suggestion(
      mUniffiPtr.IntoRust(),
      mSuggestion.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissSuggestion : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mSuggestionUrl{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststore_dismiss_suggestion (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSuggestionUrl.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_dismiss_suggestion(
      mUniffiPtr.IntoRust(),
      mSuggestionUrl.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGeonameAlternates : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mGeoname{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststore_fetch_geoname_alternates (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mGeoname.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_fetch_geoname_alternates(
        mUniffiPtr.IntoRust(),
        mGeoname.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGeonames : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mQuery{};
  FfiValueInt<int8_t> mMatchNamePrefix{};
  FfiValueRustBuffer mFilter{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 4) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststore_fetch_geonames (expected: 4, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mQuery.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mMatchNamePrefix.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mFilter.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_fetch_geonames(
        mUniffiPtr.IntoRust(),
        mQuery.IntoRust(),
        mMatchNamePrefix.IntoRust(),
        mFilter.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGlobalConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststore_fetch_global_config (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_fetch_global_config(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchProviderConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mProvider{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststore_fetch_provider_config (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mProvider.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_fetch_provider_config(
        mUniffiPtr.IntoRust(),
        mProvider.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIngest : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mConstraints{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststore_ingest (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mConstraints.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_ingest(
        mUniffiPtr.IntoRust(),
        mConstraints.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreInterrupt : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mKind{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststore_interrupt (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mKind.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_interrupt(
      mUniffiPtr.IntoRust(),
      mKind.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIsDismissedByKey : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mKey{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststore_is_dismissed_by_key (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mKey.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_suggest_fn_method_suggeststore_is_dismissed_by_key(
        mUniffiPtr.IntoRust(),
        mKey.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIsDismissedBySuggestion : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mSuggestion{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststore_is_dismissed_by_suggestion (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSuggestion.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_suggest_fn_method_suggeststore_is_dismissed_by_suggestion(
        mUniffiPtr.IntoRust(),
        mSuggestion.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreQuery : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mQuery{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststore_query (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mQuery.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_query(
        mUniffiPtr.IntoRust(),
        mQuery.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreQueryWithMetrics : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mQuery{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststore_query_with_metrics (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mQuery.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_query_with_metrics(
        mUniffiPtr.IntoRust(),
        mQuery.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnConstructorSuggeststorebuilderNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_constructor_suggeststorebuilder_new(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderBuild : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststorebuilder_build (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStore::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_build(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderCachePath : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststorebuilder_cache_path (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mPath.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_cache_path(
        mUniffiPtr.IntoRust(),
        mPath.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderDataPath : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststorebuilder_data_path (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mPath.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_data_path(
        mUniffiPtr.IntoRust(),
        mPath.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderLoadExtension : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueRustBuffer mLibrary{};
  FfiValueRustBuffer mEntryPoint{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststorebuilder_load_extension (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLibrary.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mEntryPoint.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_load_extension(
        mUniffiPtr.IntoRust(),
        mLibrary.IntoRust(),
        mEntryPoint.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsBucketName : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueRustBuffer mBucketName{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_bucket_name (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBucketName.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_bucket_name(
        mUniffiPtr.IntoRust(),
        mBucketName.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsServer : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueRustBuffer mServer{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_server (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mServer.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_server(
        mUniffiPtr.IntoRust(),
        mServer.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsService : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mRsService{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_service (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRsService.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_service(
        mUniffiPtr.IntoRust(),
        mRsService.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreAddRemoteCommand : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiPtr{};
  FfiValueRustBuffer mDeviceId{};
  FfiValueRustBuffer mCommand{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_remotecommandstore_add_remote_command (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mDeviceId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mCommand.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_add_remote_command(
        mUniffiPtr.IntoRust(),
        mDeviceId.IntoRust(),
        mCommand.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreAddRemoteCommandAt : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiPtr{};
  FfiValueRustBuffer mDeviceId{};
  FfiValueRustBuffer mCommand{};
  FfiValueInt<int64_t> mWhen{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 4) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_remotecommandstore_add_remote_command_at (expected: 4, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mDeviceId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mCommand.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mWhen.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_add_remote_command_at(
        mUniffiPtr.IntoRust(),
        mDeviceId.IntoRust(),
        mCommand.IntoRust(),
        mWhen.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreGetUnsentCommands : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_remotecommandstore_get_unsent_commands (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_get_unsent_commands(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreRemoveRemoteCommand : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiPtr{};
  FfiValueRustBuffer mDeviceId{};
  FfiValueRustBuffer mCommand{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_remotecommandstore_remove_remote_command (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mDeviceId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mCommand.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_remove_remote_command(
        mUniffiPtr.IntoRust(),
        mDeviceId.IntoRust(),
        mCommand.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreSetPendingCommandSent : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiPtr{};
  FfiValueRustBuffer mCommand{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_remotecommandstore_set_pending_command_sent (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCommand.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_set_pending_command_sent(
        mUniffiPtr.IntoRust(),
        mCommand.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineApply : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsbridgedengine_apply (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_apply(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineEnsureCurrentSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mNewSyncId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsbridgedengine_ensure_current_sync_id (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNewSyncId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_ensure_current_sync_id(
        mUniffiPtr.IntoRust(),
        mNewSyncId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineLastSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsbridgedengine_last_sync (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_last_sync(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedenginePrepareForSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mClientData{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsbridgedengine_prepare_for_sync (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mClientData.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_prepare_for_sync(
      mUniffiPtr.IntoRust(),
      mClientData.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineReset : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsbridgedengine_reset (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_reset(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineResetSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsbridgedengine_reset_sync_id (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_reset_sync_id(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSetLastSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};
  FfiValueInt<int64_t> mLastSync{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsbridgedengine_set_last_sync (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLastSync.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_set_last_sync(
      mUniffiPtr.IntoRust(),
      mLastSync.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSetUploaded : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};
  FfiValueInt<int64_t> mNewTimestamp{};
  FfiValueRustBuffer mUploadedIds{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsbridgedengine_set_uploaded (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNewTimestamp.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mUploadedIds.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_set_uploaded(
      mUniffiPtr.IntoRust(),
      mNewTimestamp.IntoRust(),
      mUploadedIds.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineStoreIncoming : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mIncomingEnvelopesAsJson{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsbridgedengine_store_incoming (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mIncomingEnvelopesAsJson.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_store_incoming(
      mUniffiPtr.IntoRust(),
      mIncomingEnvelopesAsJson.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncFinished : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsbridgedengine_sync_finished (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_sync_finished(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsbridgedengine_sync_id (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_sync_id(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncStarted : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsbridgedengine_sync_started (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_sync_started(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineWipe : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsbridgedengine_wipe (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_wipe(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnConstructorTabsstoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_constructor_tabsstore_new (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleTabsTabsStore::FromRust(
      uniffi_tabs_fn_constructor_tabsstore_new(
        mPath.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreBridgedEngine : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsstore_bridged_engine (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleTabsTabsBridgedEngine::FromRust(
      uniffi_tabs_fn_method_tabsstore_bridged_engine(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreCloseConnection : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsstore_close_connection (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsstore_close_connection(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreGetAll : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsstore_get_all (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsstore_get_all(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreNewRemoteCommandStore : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsstore_new_remote_command_store (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleTabsRemoteCommandStore::FromRust(
      uniffi_tabs_fn_method_tabsstore_new_remote_command_store(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreRegisterWithSyncManager : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsstore_register_with_sync_manager (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsstore_register_with_sync_manager(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreSetLocalTabs : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};
  FfiValueRustBuffer mRemoteTabs{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsstore_set_local_tabs (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRemoteTabs.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsstore_set_local_tabs(
      mUniffiPtr.IntoRust(),
      mRemoteTabs.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreSetLocalTabsInfo : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};
  FfiValueRustBuffer mInfo{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tabs_fn_method_tabsstore_set_local_tabs_info (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mInfo.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsstore_set_local_tabs_info(
      mUniffiPtr.IntoRust(),
      mInfo.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTracingSupportFnFuncRegisterEventSink : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mTargets{};
  FfiValueObjectHandleTracingEventSink mSink{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tracing_support_fn_func_register_event_sink (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mTargets.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSink.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_tracing_support_fn_func_register_event_sink(
        mTargets.IntoRust(),
        mSink.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTracingSupportFnFuncUnregisterEventSink : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mId{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_tracing_support_fn_func_unregister_event_sink (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mId.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tracing_support_fn_func_unregister_event_sink(
      mId.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiViaductFnFuncAllowAndroidEmulatorLoopback : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_viaduct_fn_func_allow_android_emulator_loopback(
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiViaductFnFuncInitBackend : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleViaductBackend mBackend{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_viaduct_fn_func_init_backend (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mBackend.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_viaduct_fn_func_init_backend(
      mBackend.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiViaductFnFuncSetGlobalDefaultUserAgent : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mUserAgent{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_viaduct_fn_func_set_global_default_user_agent (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUserAgent.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_viaduct_fn_func_set_global_default_user_agent(
      mUserAgent.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiViaductFnMethodBackendSendRequest : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiViaductFnMethodBackendSendRequest() : UniffiAsyncCallHandler(
        ffi_viaduct_rust_future_poll_rust_buffer,
        ffi_viaduct_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleViaductBackend mUniffiPtr{};
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    FfiValueRustBuffer mRequest{};
    mRequest.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    FfiValueRustBuffer mSettings{};
    mSettings.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_viaduct_fn_method_backend_send_request(
      mUniffiPtr.IntoRust(),
      mRequest.IntoRust(),
      mSettings.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_viaduct_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineApply : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragebridgedengine_apply (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_apply(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineEnsureCurrentSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mNewSyncId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragebridgedengine_ensure_current_sync_id (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNewSyncId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_ensure_current_sync_id(
        mUniffiPtr.IntoRust(),
        mNewSyncId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineLastSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragebridgedengine_last_sync (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_last_sync(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedenginePrepareForSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mClientData{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragebridgedengine_prepare_for_sync (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mClientData.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_prepare_for_sync(
      mUniffiPtr.IntoRust(),
      mClientData.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineReset : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineResetSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset_sync_id (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset_sync_id(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSetLastSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};
  FfiValueInt<int64_t> mLastSync{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_last_sync (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLastSync.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_last_sync(
      mUniffiPtr.IntoRust(),
      mLastSync.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSetUploaded : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};
  FfiValueInt<int64_t> mServerModifiedMillis{};
  FfiValueRustBuffer mGuids{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_uploaded (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mServerModifiedMillis.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mGuids.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_uploaded(
      mUniffiPtr.IntoRust(),
      mServerModifiedMillis.IntoRust(),
      mGuids.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineStoreIncoming : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mIncoming{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragebridgedengine_store_incoming (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mIncoming.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_store_incoming(
      mUniffiPtr.IntoRust(),
      mIncoming.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncFinished : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_finished (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_finished(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_id (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_id(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncStarted : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_started (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_started(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineWipe : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragebridgedengine_wipe (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_wipe(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnConstructorWebextstoragestoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_constructor_webextstoragestore_new (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleWebextstorageWebExtStorageStore::FromRust(
      uniffi_webext_storage_fn_constructor_webextstoragestore_new(
        mPath.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreBridgedEngine : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragestore_bridged_engine (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_bridged_engine(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreClear : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};
  FfiValueRustBuffer mExtId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragestore_clear (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_clear(
        mUniffiPtr.IntoRust(),
        mExtId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreClose : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragestore_close (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragestore_close(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGet : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};
  FfiValueRustBuffer mExtId{};
  FfiValueRustBuffer mKeys{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragestore_get (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mKeys.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_get(
        mUniffiPtr.IntoRust(),
        mExtId.IntoRust(),
        mKeys.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetBytesInUse : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};
  FfiValueRustBuffer mExtId{};
  FfiValueRustBuffer mKeys{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragestore_get_bytes_in_use (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mKeys.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_get_bytes_in_use(
        mUniffiPtr.IntoRust(),
        mExtId.IntoRust(),
        mKeys.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetKeys : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};
  FfiValueRustBuffer mExtId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragestore_get_keys (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_get_keys(
        mUniffiPtr.IntoRust(),
        mExtId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetSyncedChanges : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragestore_get_synced_changes (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_get_synced_changes(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreRemove : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};
  FfiValueRustBuffer mExtId{};
  FfiValueRustBuffer mKeys{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragestore_remove (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mKeys.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_remove(
        mUniffiPtr.IntoRust(),
        mExtId.IntoRust(),
        mKeys.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreSet : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};
  FfiValueRustBuffer mExtId{};
  FfiValueRustBuffer mVal{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 3) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_webext_storage_fn_method_webextstoragestore_set (expected: 3, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mVal.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_set(
        mUniffiPtr.IntoRust(),
        mExtId.IntoRust(),
        mVal.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};

#ifdef MOZ_UNIFFI_FIXTURES
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF32 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF32() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_f32,
        ffi_uniffi_bindings_tests_rust_future_free_f32
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueFloat<float> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueFloat<float> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_f32(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<float>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_f32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF64 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF64() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_f64,
        ffi_uniffi_bindings_tests_rust_future_free_f64
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueFloat<double> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueFloat<double> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_f64(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_f64(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI16 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI16() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_i16,
        ffi_uniffi_bindings_tests_rust_future_free_i16
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<int16_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<int16_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i16(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int16_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_i16(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI32 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI32() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_i32,
        ffi_uniffi_bindings_tests_rust_future_free_i32
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<int32_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<int32_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i32(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int32_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_i32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI64 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI64() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_i64,
        ffi_uniffi_bindings_tests_rust_future_free_i64
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<int64_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<int64_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i64(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_i64(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI8 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI8() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_i8,
        ffi_uniffi_bindings_tests_rust_future_free_i8
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<int8_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<int8_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i8(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_i8(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripMap : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripMap() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueRustBuffer mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_map(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripObj : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripObj() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u64,
        ffi_uniffi_bindings_tests_rust_future_free_u64
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncInterface mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_obj(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsAsyncInterface::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u64(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripString : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripString() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueRustBuffer mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_string(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU16 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU16() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u16,
        ffi_uniffi_bindings_tests_rust_future_free_u16
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint16_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<uint16_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u16(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint16_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u16(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU32 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU32() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u32,
        ffi_uniffi_bindings_tests_rust_future_free_u32
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint32_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<uint32_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u32(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU64 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU64() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u64,
        ffi_uniffi_bindings_tests_rust_future_free_u64
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint64_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<uint64_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u64(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u64(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU8 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU8() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u8,
        ffi_uniffi_bindings_tests_rust_future_free_u8
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint8_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<uint8_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u8(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint8_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u8(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripVec : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripVec() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueRustBuffer mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_vec(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncThrowError : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncThrowError() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_void,
        ffi_uniffi_bindings_tests_rust_future_free_void
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_throw_error(
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    ffi_uniffi_bindings_tests_rust_future_complete_void(mFutureHandle, aOutStatus);
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncCloneInterface : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mInt{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_clone_interface (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsTestInterface::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_clone_interface(
        mInt.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncCreateAsyncTestTraitInterface : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_create_async_test_trait_interface (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mValue.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_create_async_test_trait_interface(
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncCreateTestTraitInterface : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_create_test_trait_interface (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mValue.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_create_test_trait_interface(
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithDefault : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mArg{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_func_with_default (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mArg.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_func_with_default(
        mArg.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithError : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mInput{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_func_with_error (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mInput.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_func_with_error(
      mInput.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithFlatError : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mInput{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_func_with_flat_error (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mInput.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_func_with_flat_error(
      mInput.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithMultiWordArg : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mTheArgument{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_func_with_multi_word_arg (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mTheArgument.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_func_with_multi_word_arg(
        mTheArgument.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncGetCustomTypesDemo : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_get_custom_types_demo(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceGetValue : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceGetValue() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u32,
        ffi_uniffi_bindings_tests_rust_future_free_u32
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint32_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mInt{};
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_invoke_async_test_trait_interface_get_value(
      mInt.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceNoop : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceNoop() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_void,
        ffi_uniffi_bindings_tests_rust_future_free_void
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mInt{};
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_invoke_async_test_trait_interface_noop(
      mInt.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    ffi_uniffi_bindings_tests_rust_future_complete_void(mFutureHandle, aOutStatus);
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceSetValue : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceSetValue() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_void,
        ffi_uniffi_bindings_tests_rust_future_free_void
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mInt{};
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    FfiValueInt<uint32_t> mValue{};
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_invoke_async_test_trait_interface_set_value(
      mInt.IntoRust(),
      mValue.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    ffi_uniffi_bindings_tests_rust_future_complete_void(mFutureHandle, aOutStatus);
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceThrowIfEqual : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceThrowIfEqual() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mInt{};
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    FfiValueRustBuffer mNumbers{};
    mNumbers.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_invoke_async_test_trait_interface_throw_if_equal(
      mInt.IntoRust(),
      mNumbers.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceGetValue : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceGetValue() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u32,
        ffi_uniffi_bindings_tests_rust_future_free_u32
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint32_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsTestAsyncCallbackInterface mCbi{};
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_invoke_test_async_callback_interface_get_value(
      mCbi.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceNoop : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceNoop() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_void,
        ffi_uniffi_bindings_tests_rust_future_free_void
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsTestAsyncCallbackInterface mCbi{};
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_invoke_test_async_callback_interface_noop(
      mCbi.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    ffi_uniffi_bindings_tests_rust_future_complete_void(mFutureHandle, aOutStatus);
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceSetValue : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceSetValue() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_void,
        ffi_uniffi_bindings_tests_rust_future_free_void
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsTestAsyncCallbackInterface mCbi{};
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    FfiValueInt<uint32_t> mValue{};
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_invoke_test_async_callback_interface_set_value(
      mCbi.IntoRust(),
      mValue.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    ffi_uniffi_bindings_tests_rust_future_complete_void(mFutureHandle, aOutStatus);
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceThrowIfEqual : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceThrowIfEqual() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsTestAsyncCallbackInterface mCbi{};
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    FfiValueRustBuffer mNumbers{};
    mNumbers.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_invoke_test_async_callback_interface_throw_if_equal(
      mCbi.IntoRust(),
      mNumbers.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceGetValue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestCallbackInterface mCbi{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_get_value (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_get_value(
        mCbi.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceNoop : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestCallbackInterface mCbi{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_noop (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_noop(
      mCbi.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceSetValue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestCallbackInterface mCbi{};
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_set_value (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_set_value(
      mCbi.IntoRust(),
      mValue.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceThrowIfEqual : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestCallbackInterface mCbi{};
  FfiValueRustBuffer mNumbers{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_throw_if_equal (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNumbers.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_throw_if_equal(
        mCbi.IntoRust(),
        mNumbers.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestTraitInterfaceGetValue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mInt{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_get_value (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_get_value(
        mInt.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestTraitInterfaceNoop : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mInt{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_noop (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_noop(
      mInt.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestTraitInterfaceSetValue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mInt{};
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_set_value (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_set_value(
      mInt.IntoRust(),
      mValue.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestTraitInterfaceThrowIfEqual : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mInt{};
  FfiValueRustBuffer mNumbers{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_throw_if_equal (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNumbers.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_throw_if_equal(
        mInt.IntoRust(),
        mNumbers.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripAsyncTestTraitInterface : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mInt{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_async_test_trait_interface (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_async_test_trait_interface(
        mInt.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripAsyncTestTraitInterfaceList : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mIntList{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_async_test_trait_interface_list (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mIntList.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_async_test_trait_interface_list(
        mIntList.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripBool : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int8_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_bool (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_bool(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexCompound : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_compound (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_compound(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexEnum : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mEn{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_enum (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mEn.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_enum(
        mEn.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexRec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRec{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_rec (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mRec.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_rec(
        mRec.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripCustomType : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mHandle{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_custom_type (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mHandle.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_custom_type(
        mHandle.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripEnumNoData : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mEn{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_no_data (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mEn.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_no_data(
        mEn.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripEnumWithData : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mEn{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_with_data (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mEn.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_with_data(
        mEn.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripF32 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueFloat<float> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<float> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_f32 (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<float>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_f32(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripF64 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueFloat<double> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<double> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_f64 (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_f64(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripHashMap : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_hash_map (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_hash_map(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI16 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int16_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int16_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_i16 (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int16_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_i16(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI32 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int32_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_i32 (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_i32(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI64 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int64_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_i64 (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_i64(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI8 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int8_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_i8 (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_i8(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripOption : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_option (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_option(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripSimpleRec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRec{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_simple_rec (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mRec.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_simple_rec(
        mRec.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripString : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_string (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_string(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripTestTraitInterface : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mInt{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_test_trait_interface (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_test_trait_interface(
        mInt.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripTestTraitInterfaceList : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mIntList{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_test_trait_interface_list (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mIntList.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_test_trait_interface_list(
        mIntList.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripTimeIntervalMs : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int64_t> mTime{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_time_interval_ms (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mTime.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_time_interval_ms(
        mTime.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripTimeIntervalSecDbl : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueFloat<double> mTime{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<double> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_time_interval_sec_dbl (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mTime.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_time_interval_sec_dbl(
        mTime.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripTimeIntervalSecFlt : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueFloat<float> mTime{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<float> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_time_interval_sec_flt (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mTime.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<float>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_time_interval_sec_flt(
        mTime.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU16 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint16_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint16_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_u16 (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint16_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_u16(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU32 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_u32 (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_u32(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU64 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_u64 (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_u64(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU8 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint8_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_u8 (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint8_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_u8(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripUrl : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mUrl{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_url (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUrl.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_url(
        mUrl.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripVec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_roundtrip_vec (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_vec(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncSumWithManyTypes : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint8_t> mA{};
  FfiValueInt<int8_t> mB{};
  FfiValueInt<uint16_t> mC{};
  FfiValueInt<int16_t> mD{};
  FfiValueInt<uint32_t> mE{};
  FfiValueInt<int32_t> mF{};
  FfiValueInt<uint64_t> mG{};
  FfiValueInt<int64_t> mH{};
  FfiValueFloat<float> mI{};
  FfiValueFloat<double> mJ{};
  FfiValueInt<int8_t> mNegate{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<double> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 11) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_sum_with_many_types (expected: 11, actual: %zu)", aArgs.Length()));
      return;
    }
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mB.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mC.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mD.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
    mE.Lower(aArgs[4], aError);
    if (aError.Failed()) {
      return;
    }
    mF.Lower(aArgs[5], aError);
    if (aError.Failed()) {
      return;
    }
    mG.Lower(aArgs[6], aError);
    if (aError.Failed()) {
      return;
    }
    mH.Lower(aArgs[7], aError);
    if (aError.Failed()) {
      return;
    }
    mI.Lower(aArgs[8], aError);
    if (aError.Failed()) {
      return;
    }
    mJ.Lower(aArgs[9], aError);
    if (aError.Failed()) {
      return;
    }
    mNegate.Lower(aArgs[10], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_sum_with_many_types(
        mA.IntoRust(),
        mB.IntoRust(),
        mC.IntoRust(),
        mD.IntoRust(),
        mE.IntoRust(),
        mF.IntoRust(),
        mG.IntoRust(),
        mH.IntoRust(),
        mI.IntoRust(),
        mJ.IntoRust(),
        mNegate.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncSwapTestInterfaces : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mInterfaces{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_func_swap_test_interfaces (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mInterfaces.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_swap_test_interfaces(
        mInterfaces.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncTestFunc : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_test_func(
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorTestinterfaceNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_constructor_testinterface_new (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mValue.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsTestInterface::FromRust(
      uniffi_uniffi_bindings_tests_fn_constructor_testinterface_new(
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTestinterfaceGetValue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_method_testinterface_get_value (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_method_testinterface_get_value(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTestinterfaceRefCount : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_method_testinterface_ref_count (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_method_testinterface_ref_count(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorAsyncinterfaceNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mName{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_constructor_asyncinterface_new (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mName.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsAsyncInterface::FromRust(
      uniffi_uniffi_bindings_tests_fn_constructor_asyncinterface_new(
        mName.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsyncinterfaceName : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsyncinterfaceName() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncInterface mUniffiPtr{};
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_method_asyncinterface_name(
      mUniffiPtr.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceNoop : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceNoop() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_void,
        ffi_uniffi_bindings_tests_rust_future_free_void
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mUniffiPtr{};
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_method_asynctesttraitinterface_noop(
      mUniffiPtr.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    ffi_uniffi_bindings_tests_rust_future_complete_void(mFutureHandle, aOutStatus);
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceGetValue : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceGetValue() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u32,
        ffi_uniffi_bindings_tests_rust_future_free_u32
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint32_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mUniffiPtr{};
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_method_asynctesttraitinterface_get_value(
      mUniffiPtr.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceSetValue : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceSetValue() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_void,
        ffi_uniffi_bindings_tests_rust_future_free_void
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mUniffiPtr{};
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    FfiValueInt<uint32_t> mValue{};
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_method_asynctesttraitinterface_set_value(
      mUniffiPtr.IntoRust(),
      mValue.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    ffi_uniffi_bindings_tests_rust_future_complete_void(mFutureHandle, aOutStatus);
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceThrowIfEqual : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceThrowIfEqual() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mUniffiPtr{};
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    FfiValueRustBuffer mNumbers{};
    mNumbers.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_method_asynctesttraitinterface_throw_if_equal(
      mUniffiPtr.IntoRust(),
      mNumbers.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorComplexmethodsNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsComplexMethods::FromRust(
      uniffi_uniffi_bindings_tests_fn_constructor_complexmethods_new(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodComplexmethodsMethodWithDefault : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods mUniffiPtr{};
  FfiValueRustBuffer mArg{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_default (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mArg.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_default(
        mUniffiPtr.IntoRust(),
        mArg.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodComplexmethodsMethodWithMultiWordArg : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods mUniffiPtr{};
  FfiValueRustBuffer mTheArgument{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_multi_word_arg (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mTheArgument.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_multi_word_arg(
        mUniffiPtr.IntoRust(),
        mTheArgument.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTesttraitinterfaceNoop : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_noop (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_noop(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTesttraitinterfaceGetValue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_get_value (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_get_value(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTesttraitinterfaceSetValue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mUniffiPtr{};
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_set_value (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_set_value(
      mUniffiPtr.IntoRust(),
      mValue.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTesttraitinterfaceThrowIfEqual : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mUniffiPtr{};
  FfiValueRustBuffer mNumbers{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 2) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_throw_if_equal (expected: 2, actual: %zu)", aArgs.Length()));
      return;
    }
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNumbers.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_throw_if_equal(
        mUniffiPtr.IntoRust(),
        mNumbers.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsCollisionFnFuncInvokeCollisionCallback : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsCollisionTestCallbackInterface mCb{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_collision_fn_func_invoke_collision_callback (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mCb.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_collision_fn_func_invoke_collision_callback(
        mCb.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtCustomType : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mCustom{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_custom_type (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mCustom.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_custom_type(
        mCustom.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtEnum : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mEn{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_enum (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mEn.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_enum(
        mEn.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtInterface : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mInt{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_interface (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsTestInterface::FromRust(
      uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_interface(
        mInt.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtRecord : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRec{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    if (aArgs.Length() < 1) {
      aError.ThrowUnknownError(nsPrintfCString("LowerRustArgs: Incorrect argument length for uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_record (expected: 1, actual: %zu)", aArgs.Length()));
      return;
    }
    mRec.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_record(
        mRec.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
#endif /* MOZ_UNIFFI_FIXTURES */

UniquePtr<UniffiSyncCallHandler> GetSyncCallHandler(uint64_t aId) {
  switch (aId) {

    case 1: {
      return MakeUnique<ScaffoldingCallHandlerUniffiContextIdFnConstructorContextidcomponentNew>();
    }
    case 2: {
      return MakeUnique<ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentForceRotation>();
    }
    case 3: {
      return MakeUnique<ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentRequest>();
    }
    case 4: {
      return MakeUnique<ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentUnsetCallback>();
    }
    case 5: {
      return MakeUnique<ScaffoldingCallHandlerUniffiFilterAdultFnConstructorFilteradultcomponentNew>();
    }
    case 6: {
      return MakeUnique<ScaffoldingCallHandlerUniffiFilterAdultFnMethodFilteradultcomponentContains>();
    }
    case 7: {
      return MakeUnique<ScaffoldingCallHandlerUniffiInitRustComponentsFnFuncInitialize>();
    }
    case 8: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnFuncCheckCanary>();
    }
    case 9: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnFuncCreateCanary>();
    }
    case 10: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnFuncCreateKey>();
    }
    case 11: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnFuncCreateLoginStoreWithNssKeymanager>();
    }
    case 12: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnFuncCreateLoginStoreWithStaticKeyManager>();
    }
    case 13: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnFuncCreateManagedEncdec>();
    }
    case 14: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnFuncCreateStaticKeyManager>();
    }
    case 15: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodEncryptordecryptorDecrypt>();
    }
    case 16: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodEncryptordecryptorEncrypt>();
    }
    case 17: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodKeymanagerGetKey>();
    }
    case 18: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnConstructorLoginstoreNew>();
    }
    case 19: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreAdd>();
    }
    case 20: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreAddMany>();
    }
    case 21: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreAddManyWithMeta>();
    }
    case 22: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreAddOrUpdate>();
    }
    case 23: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreAddWithMeta>();
    }
    case 24: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreArePotentiallyVulnerablePasswords>();
    }
    case 25: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreCount>();
    }
    case 26: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreCountByFormActionOrigin>();
    }
    case 27: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreCountByOrigin>();
    }
    case 28: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreDelete>();
    }
    case 29: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreDeleteMany>();
    }
    case 30: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreDeleteUndecryptableRecordsForRemoteReplacement>();
    }
    case 31: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreFindLoginToUpdate>();
    }
    case 32: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreGet>();
    }
    case 33: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreGetByBaseDomain>();
    }
    case 34: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreGetCheckpoint>();
    }
    case 35: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreHasLoginsByBaseDomain>();
    }
    case 36: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreIsBreachAlertDismissed>();
    }
    case 37: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreIsEmpty>();
    }
    case 38: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreIsPotentiallyBreached>();
    }
    case 39: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreIsPotentiallyVulnerablePassword>();
    }
    case 40: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreList>();
    }
    case 41: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreRecordBreach>();
    }
    case 42: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreRecordBreachAlertDismissal>();
    }
    case 43: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreRecordBreachAlertDismissalTime>();
    }
    case 44: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreRecordPotentiallyVulnerablePasswords>();
    }
    case 45: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreRegisterWithSyncManager>();
    }
    case 46: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreReset>();
    }
    case 47: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreResetAllBreaches>();
    }
    case 48: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreRunMaintenance>();
    }
    case 49: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreSetCheckpoint>();
    }
    case 50: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreShutdown>();
    }
    case 51: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreTouch>();
    }
    case 52: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreUpdate>();
    }
    case 53: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodLoginstoreWipeLocal>();
    }
    case 54: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnConstructorManagedencryptordecryptorNew>();
    }
    case 55: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnConstructorNsskeymanagerNew>();
    }
    case 56: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodNsskeymanagerIntoDynKeyManager>();
    }
    case 60: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnConstructorStatickeymanagerNew>();
    }
    case 61: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnFuncScore>();
    }
    case 62: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnConstructorRelevancystoreNew>();
    }
    case 63: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditInit>();
    }
    case 64: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditSelect>();
    }
    case 65: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditUpdate>();
    }
    case 66: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreClose>();
    }
    case 67: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreEnsureInterestDataPopulated>();
    }
    case 68: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreGetBanditData>();
    }
    case 69: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreIngest>();
    }
    case 70: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreInterrupt>();
    }
    case 71: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreUserInterestVector>();
    }
    case 72: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnConstructorRemotesettingsNew>();
    }
    case 73: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsDownloadAttachmentToPath>();
    }
    case 74: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsGetRecords>();
    }
    case 75: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsGetRecordsSince>();
    }
    case 76: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientCollectionName>();
    }
    case 77: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetAttachment>();
    }
    case 78: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetRecords>();
    }
    case 79: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetRecordsMap>();
    }
    case 80: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientShutdown>();
    }
    case 81: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientSync>();
    }
    case 82: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnConstructorRemotesettingsserviceNew>();
    }
    case 83: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceClientUrl>();
    }
    case 84: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceMakeClient>();
    }
    case 85: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceSync>();
    }
    case 86: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceUpdateConfig>();
    }
    case 87: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnConstructorSearchengineselectorNew>();
    }
    case 88: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorClearSearchConfig>();
    }
    case 89: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorFilterEngineConfiguration>();
    }
    case 90: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorSetConfigOverrides>();
    }
    case 91: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorSetSearchConfig>();
    }
    case 92: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorUseRemoteSettingsServer>();
    }
    case 93: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnFuncRawSuggestionUrlMatches>();
    }
    case 94: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnConstructorSuggeststoreNew>();
    }
    case 95: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreAnyDismissedSuggestions>();
    }
    case 96: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreClear>();
    }
    case 97: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreClearDismissedSuggestions>();
    }
    case 98: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissByKey>();
    }
    case 99: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissBySuggestion>();
    }
    case 100: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissSuggestion>();
    }
    case 101: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGeonameAlternates>();
    }
    case 102: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGeonames>();
    }
    case 103: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGlobalConfig>();
    }
    case 104: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchProviderConfig>();
    }
    case 105: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIngest>();
    }
    case 106: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreInterrupt>();
    }
    case 107: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIsDismissedByKey>();
    }
    case 108: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIsDismissedBySuggestion>();
    }
    case 109: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreQuery>();
    }
    case 110: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreQueryWithMetrics>();
    }
    case 111: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnConstructorSuggeststorebuilderNew>();
    }
    case 112: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderBuild>();
    }
    case 113: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderCachePath>();
    }
    case 114: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderDataPath>();
    }
    case 115: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderLoadExtension>();
    }
    case 116: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsBucketName>();
    }
    case 117: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsServer>();
    }
    case 118: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsService>();
    }
    case 119: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreAddRemoteCommand>();
    }
    case 120: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreAddRemoteCommandAt>();
    }
    case 121: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreGetUnsentCommands>();
    }
    case 122: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreRemoveRemoteCommand>();
    }
    case 123: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreSetPendingCommandSent>();
    }
    case 124: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineApply>();
    }
    case 125: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineEnsureCurrentSyncId>();
    }
    case 126: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineLastSync>();
    }
    case 127: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedenginePrepareForSync>();
    }
    case 128: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineReset>();
    }
    case 129: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineResetSyncId>();
    }
    case 130: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSetLastSync>();
    }
    case 131: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSetUploaded>();
    }
    case 132: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineStoreIncoming>();
    }
    case 133: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncFinished>();
    }
    case 134: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncId>();
    }
    case 135: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncStarted>();
    }
    case 136: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineWipe>();
    }
    case 137: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnConstructorTabsstoreNew>();
    }
    case 138: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreBridgedEngine>();
    }
    case 139: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreCloseConnection>();
    }
    case 140: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreGetAll>();
    }
    case 141: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreNewRemoteCommandStore>();
    }
    case 142: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreRegisterWithSyncManager>();
    }
    case 143: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreSetLocalTabs>();
    }
    case 144: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreSetLocalTabsInfo>();
    }
    case 145: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTracingSupportFnFuncRegisterEventSink>();
    }
    case 146: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTracingSupportFnFuncUnregisterEventSink>();
    }
    case 147: {
      return MakeUnique<ScaffoldingCallHandlerUniffiViaductFnFuncAllowAndroidEmulatorLoopback>();
    }
    case 148: {
      return MakeUnique<ScaffoldingCallHandlerUniffiViaductFnFuncInitBackend>();
    }
    case 149: {
      return MakeUnique<ScaffoldingCallHandlerUniffiViaductFnFuncSetGlobalDefaultUserAgent>();
    }
    case 151: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineApply>();
    }
    case 152: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineEnsureCurrentSyncId>();
    }
    case 153: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineLastSync>();
    }
    case 154: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedenginePrepareForSync>();
    }
    case 155: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineReset>();
    }
    case 156: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineResetSyncId>();
    }
    case 157: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSetLastSync>();
    }
    case 158: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSetUploaded>();
    }
    case 159: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineStoreIncoming>();
    }
    case 160: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncFinished>();
    }
    case 161: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncId>();
    }
    case 162: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncStarted>();
    }
    case 163: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineWipe>();
    }
    case 164: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnConstructorWebextstoragestoreNew>();
    }
    case 165: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreBridgedEngine>();
    }
    case 166: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreClear>();
    }
    case 167: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreClose>();
    }
    case 168: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGet>();
    }
    case 169: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetBytesInUse>();
    }
    case 170: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetKeys>();
    }
    case 171: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetSyncedChanges>();
    }
    case 172: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreRemove>();
    }
    case 173: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreSet>();
    }

#ifdef MOZ_UNIFFI_FIXTURES
    case 189: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncCloneInterface>();
    }
    case 190: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncCreateAsyncTestTraitInterface>();
    }
    case 191: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncCreateTestTraitInterface>();
    }
    case 192: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithDefault>();
    }
    case 193: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithError>();
    }
    case 194: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithFlatError>();
    }
    case 195: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithMultiWordArg>();
    }
    case 196: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncGetCustomTypesDemo>();
    }
    case 205: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceGetValue>();
    }
    case 206: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceNoop>();
    }
    case 207: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceSetValue>();
    }
    case 208: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceThrowIfEqual>();
    }
    case 209: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestTraitInterfaceGetValue>();
    }
    case 210: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestTraitInterfaceNoop>();
    }
    case 211: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestTraitInterfaceSetValue>();
    }
    case 212: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestTraitInterfaceThrowIfEqual>();
    }
    case 213: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripAsyncTestTraitInterface>();
    }
    case 214: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripAsyncTestTraitInterfaceList>();
    }
    case 215: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripBool>();
    }
    case 216: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexCompound>();
    }
    case 217: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexEnum>();
    }
    case 218: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexRec>();
    }
    case 219: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripCustomType>();
    }
    case 220: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripEnumNoData>();
    }
    case 221: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripEnumWithData>();
    }
    case 222: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripF32>();
    }
    case 223: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripF64>();
    }
    case 224: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripHashMap>();
    }
    case 225: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI16>();
    }
    case 226: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI32>();
    }
    case 227: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI64>();
    }
    case 228: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI8>();
    }
    case 229: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripOption>();
    }
    case 230: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripSimpleRec>();
    }
    case 231: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripString>();
    }
    case 232: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripTestTraitInterface>();
    }
    case 233: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripTestTraitInterfaceList>();
    }
    case 234: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripTimeIntervalMs>();
    }
    case 235: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripTimeIntervalSecDbl>();
    }
    case 236: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripTimeIntervalSecFlt>();
    }
    case 237: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU16>();
    }
    case 238: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU32>();
    }
    case 239: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU64>();
    }
    case 240: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU8>();
    }
    case 241: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripUrl>();
    }
    case 242: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripVec>();
    }
    case 243: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncSumWithManyTypes>();
    }
    case 244: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncSwapTestInterfaces>();
    }
    case 245: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncTestFunc>();
    }
    case 246: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorTestinterfaceNew>();
    }
    case 247: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTestinterfaceGetValue>();
    }
    case 248: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTestinterfaceRefCount>();
    }
    case 249: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorAsyncinterfaceNew>();
    }
    case 255: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorComplexmethodsNew>();
    }
    case 256: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodComplexmethodsMethodWithDefault>();
    }
    case 257: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodComplexmethodsMethodWithMultiWordArg>();
    }
    case 258: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTesttraitinterfaceNoop>();
    }
    case 259: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTesttraitinterfaceGetValue>();
    }
    case 260: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTesttraitinterfaceSetValue>();
    }
    case 261: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTesttraitinterfaceThrowIfEqual>();
    }
    case 262: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsCollisionFnFuncInvokeCollisionCallback>();
    }
    case 263: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtCustomType>();
    }
    case 264: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtEnum>();
    }
    case 265: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtInterface>();
    }
    case 266: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtRecord>();
    }
#endif /* MOZ_UNIFFI_FIXTURES */

    default:
      return nullptr;
  }
}

UniquePtr<UniffiAsyncCallHandler> GetAsyncCallHandler(uint64_t aId) {
  switch (aId) {

    case 57: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodPrimarypasswordauthenticatorGetPrimaryPassword>();
    }
    case 58: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodPrimarypasswordauthenticatorOnAuthenticationSuccess>();
    }
    case 59: {
      return MakeUnique<ScaffoldingCallHandlerUniffiLoginsFnMethodPrimarypasswordauthenticatorOnAuthenticationFailure>();
    }
    case 150: {
      return MakeUnique<ScaffoldingCallHandlerUniffiViaductFnMethodBackendSendRequest>();
    }

#ifdef MOZ_UNIFFI_FIXTURES
    case 174: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF32>();
    }
    case 175: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF64>();
    }
    case 176: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI16>();
    }
    case 177: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI32>();
    }
    case 178: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI64>();
    }
    case 179: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI8>();
    }
    case 180: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripMap>();
    }
    case 181: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripObj>();
    }
    case 182: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripString>();
    }
    case 183: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU16>();
    }
    case 184: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU32>();
    }
    case 185: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU64>();
    }
    case 186: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU8>();
    }
    case 187: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripVec>();
    }
    case 188: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncThrowError>();
    }
    case 197: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceGetValue>();
    }
    case 198: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceNoop>();
    }
    case 199: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceSetValue>();
    }
    case 200: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceThrowIfEqual>();
    }
    case 201: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceGetValue>();
    }
    case 202: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceNoop>();
    }
    case 203: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceSetValue>();
    }
    case 204: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceThrowIfEqual>();
    }
    case 250: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsyncinterfaceName>();
    }
    case 251: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceNoop>();
    }
    case 252: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceGetValue>();
    }
    case 253: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceSetValue>();
    }
    case 254: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceThrowIfEqual>();
    }
#endif /* MOZ_UNIFFI_FIXTURES */

    default:
      return nullptr;
  }
}
/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


/**
  * Handle callback interface return values for a single return type
  */
class CallbackLowerReturnVoid {
public:
  /**
    * Lower return values
    *
    * This inputs a UniFFIScaffoldingCallResult from JS and converts it to
    * something that can be passed to Rust.
    *
    * - On success, it returns the FFI return value
    * - On error, it updates the `RustCallStatus` struct and returns a default FFI value.
    */
  static void
  Lower(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
              RustCallStatus* aOutCallStatus,
              ErrorResult& aRv) {
    aOutCallStatus->code = RUST_CALL_INTERNAL_ERROR;
    switch (aCallResult.mCode) {
      case UniFFIScaffoldingCallCode::Success: {
        aOutCallStatus->code = RUST_CALL_SUCCESS;
        break;
      }

      case UniFFIScaffoldingCallCode::Error: {
        if (!aCallResult.mData.WasPassed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnVoid] No data passed"));
          break;
        }
        FfiValueRustBuffer errorBuf;
        errorBuf.Lower(aCallResult.mData.Value(), aRv);
        if (aRv.Failed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnVoid] Failed to lower error buffer"));
          break;
        }

        aOutCallStatus->error_buf = errorBuf.IntoRust();
        aOutCallStatus->code = RUST_CALL_ERROR;
        break;
      }

      default: {
        break;
      }
    }

    }
};

/**
  * Handle callback interface return values for a single return type
  */
class CallbackLowerReturnRustBuffer {
public:
  /**
    * Lower return values
    *
    * This inputs a UniFFIScaffoldingCallResult from JS and converts it to
    * something that can be passed to Rust.
    *
    * - On success, it returns the FFI return value
    * - On error, it updates the `RustCallStatus` struct and returns a default FFI value.
    */
  static RustBuffer
  Lower(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
              RustCallStatus* aOutCallStatus,
              ErrorResult& aRv) {
    aOutCallStatus->code = RUST_CALL_INTERNAL_ERROR;
    FfiValueRustBuffer returnValue;
    switch (aCallResult.mCode) {
      case UniFFIScaffoldingCallCode::Success: {
        if (!aCallResult.mData.WasPassed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnRustBuffer] No data passed"));
          break;
        }
        returnValue.Lower(aCallResult.mData.Value(), aRv);
        if (aRv.Failed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnRustBuffer] Failed to lower return value"));
          break;
        }
        aOutCallStatus->code = RUST_CALL_SUCCESS;
        break;
      }

      case UniFFIScaffoldingCallCode::Error: {
        if (!aCallResult.mData.WasPassed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnRustBuffer] No data passed"));
          break;
        }
        FfiValueRustBuffer errorBuf;
        errorBuf.Lower(aCallResult.mData.Value(), aRv);
        if (aRv.Failed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnRustBuffer] Failed to lower error buffer"));
          break;
        }

        aOutCallStatus->error_buf = errorBuf.IntoRust();
        aOutCallStatus->code = RUST_CALL_ERROR;
        break;
      }

      default: {
        break;
      }
    }

    return returnValue.IntoRust();
    }
};

#ifdef MOZ_UNIFFI_FIXTURES

/**
  * Handle callback interface return values for a single return type
  */
class CallbackLowerReturnUInt32 {
public:
  /**
    * Lower return values
    *
    * This inputs a UniFFIScaffoldingCallResult from JS and converts it to
    * something that can be passed to Rust.
    *
    * - On success, it returns the FFI return value
    * - On error, it updates the `RustCallStatus` struct and returns a default FFI value.
    */
  static uint32_t
  Lower(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
              RustCallStatus* aOutCallStatus,
              ErrorResult& aRv) {
    aOutCallStatus->code = RUST_CALL_INTERNAL_ERROR;
    FfiValueInt<uint32_t> returnValue;
    switch (aCallResult.mCode) {
      case UniFFIScaffoldingCallCode::Success: {
        if (!aCallResult.mData.WasPassed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnUInt32] No data passed"));
          break;
        }
        returnValue.Lower(aCallResult.mData.Value(), aRv);
        if (aRv.Failed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnUInt32] Failed to lower return value"));
          break;
        }
        aOutCallStatus->code = RUST_CALL_SUCCESS;
        break;
      }

      case UniFFIScaffoldingCallCode::Error: {
        if (!aCallResult.mData.WasPassed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnUInt32] No data passed"));
          break;
        }
        FfiValueRustBuffer errorBuf;
        errorBuf.Lower(aCallResult.mData.Value(), aRv);
        if (aRv.Failed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnUInt32] Failed to lower error buffer"));
          break;
        }

        aOutCallStatus->error_buf = errorBuf.IntoRust();
        aOutCallStatus->code = RUST_CALL_ERROR;
        break;
      }

      default: {
        break;
      }
    }

    return returnValue.IntoRust();
    }
};
#endif /* MOZ_UNIFFI_FIXTURES */

// Callback interface method handlers, vtables, etc.

static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerContextIdContextIdCallback;
/**
 * Callback method handler subclass for callback_interface_context_id_context_id_callback_persist
 *
 * This is like the handler for an async function except:
 *
 * - It doesn't input the complete callback function/data
 * - It doesn't override HandleReturn and returns `nullptr` from MakeCall.
 *   This means ScheduleAsyncCall will schedule `MakeCall` and not do anything
 *   with the result, which is what we want.
 */
class CallbackInterfaceMethodContextIdContextIdCallbackPersist final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer mContextId{};
  FfiValueInt<int64_t> mCreationDate{};

public:
  CallbackInterfaceMethodContextIdContextIdCallbackPersist(
      uint64_t aUniffiHandle,
      RustBuffer aContextId,
      int64_t aCreationDate
  ) : AsyncCallbackMethodHandlerBase ("ContextIdCallback.callback_interface_context_id_context_id_callback_persist", aUniffiHandle),
      mContextId(FfiValueRustBuffer::FromRust(aContextId)),
      mCreationDate(FfiValueInt<int64_t>::FromRust(aCreationDate)){ }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    // Convert arguments
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    if (!uniffiArgs.AppendElements(2, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }
    mContextId.Lift(aCx, &uniffiArgs[0], aError);
    if (aError.Failed()) {
      return nullptr;
    }
    mCreationDate.Lift(aCx, &uniffiArgs[1], aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 0, uniffiArgs, aError);
    return nullptr;
  }
};

/**
 * callback_interface_context_id_context_id_callback_persist -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_context_id_context_id_callback_persist(
  uint64_t aUniffiHandle,
  RustBuffer aContextId,
  int64_t aCreationDate,
  void* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodContextIdContextIdCallbackPersist>(aUniffiHandle, aContextId, aCreationDate);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerContextIdContextIdCallback);
}
/**
 * Callback method handler subclass for callback_interface_context_id_context_id_callback_rotated
 *
 * This is like the handler for an async function except:
 *
 * - It doesn't input the complete callback function/data
 * - It doesn't override HandleReturn and returns `nullptr` from MakeCall.
 *   This means ScheduleAsyncCall will schedule `MakeCall` and not do anything
 *   with the result, which is what we want.
 */
class CallbackInterfaceMethodContextIdContextIdCallbackRotated final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer mOldContextId{};

public:
  CallbackInterfaceMethodContextIdContextIdCallbackRotated(
      uint64_t aUniffiHandle,
      RustBuffer aOldContextId
  ) : AsyncCallbackMethodHandlerBase ("ContextIdCallback.callback_interface_context_id_context_id_callback_rotated", aUniffiHandle),
      mOldContextId(FfiValueRustBuffer::FromRust(aOldContextId)){ }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    // Convert arguments
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }
    mOldContextId.Lift(aCx, &uniffiArgs[0], aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 1, uniffiArgs, aError);
    return nullptr;
  }
};

/**
 * callback_interface_context_id_context_id_callback_rotated -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_context_id_context_id_callback_rotated(
  uint64_t aUniffiHandle,
  RustBuffer aOldContextId,
  void* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodContextIdContextIdCallbackRotated>(aUniffiHandle, aOldContextId);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerContextIdContextIdCallback);
}

extern "C" void callback_free_context_id_context_id_callback(uint64_t aUniffiHandle) {
  if (CallbackHandleRelease(aUniffiHandle) == 0) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("ContextIdCallback.uniffi_free", aUniffiHandle),
      &gUniffiCallbackHandlerContextIdContextIdCallback);
  }
}

extern "C" uint64_t callback_clone_context_id_context_id_callback(uint64_t aUniffiHandle) {
  CallbackHandleAddRef(aUniffiHandle);
  return aUniffiHandle;
}

static VTableCallbackInterfaceContextIdContextIdCallback kUniffiVtableContextIdContextIdCallback {
  callback_free_context_id_context_id_callback,
  callback_clone_context_id_context_id_callback,
  callback_interface_context_id_context_id_callback_persist,
  callback_interface_context_id_context_id_callback_rotated,
};
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerLoginsEncryptorDecryptor;
/**
 * callback_interface_logins_encryptor_decryptor_decrypt -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_logins_encryptor_decryptor_decrypt(
  uint64_t aUniffiHandle,
  RustBuffer aCiphertext,
  RustBuffer* aUniffiOutReturn,
  RustCallStatus* aUniffiOutStatus
) {
  MOZ_RELEASE_ASSERT(NS_IsMainThread());
  // Take our own reference to the callback handler to ensure that it
  // stays alive for the duration of this call
  RefPtr<dom::UniFFICallbackHandler> jsHandler = gUniffiCallbackHandlerLoginsEncryptorDecryptor;
  // Create a JS context for the call
  JSObject* global = jsHandler->CallbackGlobalOrNull();
  if (!global) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_logins_encryptor_decryptor_decrypt] JS handler has null global"));
    return;
  }
  dom::AutoEntryScript aes(global, "callback_interface_logins_encryptor_decryptor_decrypt");

  // Convert arguments
  nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
  if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_logins_encryptor_decryptor_decrypt] Failed to allocate arguments"));
    return;
  }
  IgnoredErrorResult error;
  FfiValueRustBuffer ciphertext = FfiValueRustBuffer::FromRust(aCiphertext);
  ciphertext.Lift(aes.cx(), &uniffiArgs[0], error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_logins_encryptor_decryptor_decrypt] Failed to lift aCiphertext"));
    return;
  }

  RootedDictionary<UniFFIScaffoldingCallResult> callResult(aes.cx());
  jsHandler->CallSync(aUniffiHandle, 0, uniffiArgs, callResult, error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_logins_encryptor_decryptor_decrypt] Error invoking JS handler"));
    return;
  }
  *aUniffiOutReturn = CallbackLowerReturnRustBuffer::Lower(callResult, aUniffiOutStatus, error);
  }
/**
 * callback_interface_logins_encryptor_decryptor_encrypt -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_logins_encryptor_decryptor_encrypt(
  uint64_t aUniffiHandle,
  RustBuffer aCleartext,
  RustBuffer* aUniffiOutReturn,
  RustCallStatus* aUniffiOutStatus
) {
  MOZ_RELEASE_ASSERT(NS_IsMainThread());
  // Take our own reference to the callback handler to ensure that it
  // stays alive for the duration of this call
  RefPtr<dom::UniFFICallbackHandler> jsHandler = gUniffiCallbackHandlerLoginsEncryptorDecryptor;
  // Create a JS context for the call
  JSObject* global = jsHandler->CallbackGlobalOrNull();
  if (!global) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_logins_encryptor_decryptor_encrypt] JS handler has null global"));
    return;
  }
  dom::AutoEntryScript aes(global, "callback_interface_logins_encryptor_decryptor_encrypt");

  // Convert arguments
  nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
  if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_logins_encryptor_decryptor_encrypt] Failed to allocate arguments"));
    return;
  }
  IgnoredErrorResult error;
  FfiValueRustBuffer cleartext = FfiValueRustBuffer::FromRust(aCleartext);
  cleartext.Lift(aes.cx(), &uniffiArgs[0], error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_logins_encryptor_decryptor_encrypt] Failed to lift aCleartext"));
    return;
  }

  RootedDictionary<UniFFIScaffoldingCallResult> callResult(aes.cx());
  jsHandler->CallSync(aUniffiHandle, 1, uniffiArgs, callResult, error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_logins_encryptor_decryptor_encrypt] Error invoking JS handler"));
    return;
  }
  *aUniffiOutReturn = CallbackLowerReturnRustBuffer::Lower(callResult, aUniffiOutStatus, error);
  }

extern "C" void callback_free_logins_encryptor_decryptor(uint64_t aUniffiHandle) {
  if (CallbackHandleRelease(aUniffiHandle) == 0) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("EncryptorDecryptor.uniffi_free", aUniffiHandle),
      &gUniffiCallbackHandlerLoginsEncryptorDecryptor);
  }
}

extern "C" uint64_t callback_clone_logins_encryptor_decryptor(uint64_t aUniffiHandle) {
  CallbackHandleAddRef(aUniffiHandle);
  return aUniffiHandle;
}

static VTableCallbackInterfaceLoginsEncryptorDecryptor kUniffiVtableLoginsEncryptorDecryptor {
  callback_free_logins_encryptor_decryptor,
  callback_clone_logins_encryptor_decryptor,
  callback_interface_logins_encryptor_decryptor_decrypt,
  callback_interface_logins_encryptor_decryptor_encrypt,
};
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerLoginsKeyManager;
/**
 * callback_interface_logins_key_manager_get_key -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_logins_key_manager_get_key(
  uint64_t aUniffiHandle,
  RustBuffer* aUniffiOutReturn,
  RustCallStatus* aUniffiOutStatus
) {
  MOZ_RELEASE_ASSERT(NS_IsMainThread());
  // Take our own reference to the callback handler to ensure that it
  // stays alive for the duration of this call
  RefPtr<dom::UniFFICallbackHandler> jsHandler = gUniffiCallbackHandlerLoginsKeyManager;
  // Create a JS context for the call
  JSObject* global = jsHandler->CallbackGlobalOrNull();
  if (!global) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_logins_key_manager_get_key] JS handler has null global"));
    return;
  }
  dom::AutoEntryScript aes(global, "callback_interface_logins_key_manager_get_key");

  // Convert arguments
  nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
  if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_logins_key_manager_get_key] Failed to allocate arguments"));
    return;
  }
  IgnoredErrorResult error;

  RootedDictionary<UniFFIScaffoldingCallResult> callResult(aes.cx());
  jsHandler->CallSync(aUniffiHandle, 0, uniffiArgs, callResult, error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_logins_key_manager_get_key] Error invoking JS handler"));
    return;
  }
  *aUniffiOutReturn = CallbackLowerReturnRustBuffer::Lower(callResult, aUniffiOutStatus, error);
  }

extern "C" void callback_free_logins_key_manager(uint64_t aUniffiHandle) {
  if (CallbackHandleRelease(aUniffiHandle) == 0) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("KeyManager.uniffi_free", aUniffiHandle),
      &gUniffiCallbackHandlerLoginsKeyManager);
  }
}

extern "C" uint64_t callback_clone_logins_key_manager(uint64_t aUniffiHandle) {
  CallbackHandleAddRef(aUniffiHandle);
  return aUniffiHandle;
}

static VTableCallbackInterfaceLoginsKeyManager kUniffiVtableLoginsKeyManager {
  callback_free_logins_key_manager,
  callback_clone_logins_key_manager,
  callback_interface_logins_key_manager_get_key,
};
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerLoginsPrimaryPasswordAuthenticator;
/**
 * Callback method handler subclass for callback_interface_logins_primary_password_authenticator_get_primary_password
 *
 * This handles the specifics of the async call.
 * AsyncCallbackMethodHandlerBase::ScheduleAsyncCall handles the general parts.
 */
class CallbackInterfaceMethodLoginsPrimaryPasswordAuthenticatorGetPrimaryPassword final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  ForeignFutureCompleterust_buffer mUniffiCompleteCallback;
  uint64_t mUniffiCallbackData;

public:
  CallbackInterfaceMethodLoginsPrimaryPasswordAuthenticatorGetPrimaryPassword(
      uint64_t aUniffiHandle,
      ForeignFutureCompleterust_buffer aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData
  ) : AsyncCallbackMethodHandlerBase ("PrimaryPasswordAuthenticator.callback_interface_logins_primary_password_authenticator_get_primary_password", aUniffiHandle),
      mUniffiCompleteCallback(aUniffiCompleteCallback),
      mUniffiCallbackData(aUniffiCallbackData) { }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    // Convert arguments
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 0, uniffiArgs, aError);
    return result.forget();
  }

  void HandleReturn(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
                    ErrorResult& aRv) override {
    if (!mUniffiCompleteCallback) {
      MOZ_ASSERT_UNREACHABLE("HandleReturn called multiple times");
      return;
    }

    ForeignFutureResultRustBuffer result{};
    result.return_value  = CallbackLowerReturnRustBuffer::Lower(aCallResult, &result.call_status, aRv);
    mUniffiCompleteCallback(mUniffiCallbackData, result);
    mUniffiCompleteCallback = nullptr;
  }

  ~CallbackInterfaceMethodLoginsPrimaryPasswordAuthenticatorGetPrimaryPassword() {
    if (mUniffiCompleteCallback) {
      MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnRustBuffer] promise never completed"));
      ForeignFutureResultRustBuffer result{};
      result.call_status.code = RUST_CALL_INTERNAL_ERROR;
      mUniffiCompleteCallback(mUniffiCallbackData, result);
    }
  }
};

/**
 * callback_interface_logins_primary_password_authenticator_get_primary_password -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_logins_primary_password_authenticator_get_primary_password(
  uint64_t aUniffiHandle,
  ForeignFutureCompleterust_buffer aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFutureDroppedCallbackStruct *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodLoginsPrimaryPasswordAuthenticatorGetPrimaryPassword>(
        aUniffiHandle,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerLoginsPrimaryPasswordAuthenticator);
}
/**
 * Callback method handler subclass for callback_interface_logins_primary_password_authenticator_on_authentication_success
 *
 * This handles the specifics of the async call.
 * AsyncCallbackMethodHandlerBase::ScheduleAsyncCall handles the general parts.
 */
class CallbackInterfaceMethodLoginsPrimaryPasswordAuthenticatorOnAuthenticationSuccess final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  ForeignFutureCompletevoid mUniffiCompleteCallback;
  uint64_t mUniffiCallbackData;

public:
  CallbackInterfaceMethodLoginsPrimaryPasswordAuthenticatorOnAuthenticationSuccess(
      uint64_t aUniffiHandle,
      ForeignFutureCompletevoid aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData
  ) : AsyncCallbackMethodHandlerBase ("PrimaryPasswordAuthenticator.callback_interface_logins_primary_password_authenticator_on_authentication_success", aUniffiHandle),
      mUniffiCompleteCallback(aUniffiCompleteCallback),
      mUniffiCallbackData(aUniffiCallbackData) { }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    // Convert arguments
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 1, uniffiArgs, aError);
    return result.forget();
  }

  void HandleReturn(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
                    ErrorResult& aRv) override {
    if (!mUniffiCompleteCallback) {
      MOZ_ASSERT_UNREACHABLE("HandleReturn called multiple times");
      return;
    }

    ForeignFutureResultVoid result{};
    CallbackLowerReturnVoid::Lower(aCallResult, &result.call_status, aRv);
    mUniffiCompleteCallback(mUniffiCallbackData, result);
    mUniffiCompleteCallback = nullptr;
  }

  ~CallbackInterfaceMethodLoginsPrimaryPasswordAuthenticatorOnAuthenticationSuccess() {
    if (mUniffiCompleteCallback) {
      MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnVoid] promise never completed"));
      ForeignFutureResultVoid result{};
      result.call_status.code = RUST_CALL_INTERNAL_ERROR;
      mUniffiCompleteCallback(mUniffiCallbackData, result);
    }
  }
};

/**
 * callback_interface_logins_primary_password_authenticator_on_authentication_success -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_logins_primary_password_authenticator_on_authentication_success(
  uint64_t aUniffiHandle,
  ForeignFutureCompletevoid aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFutureDroppedCallbackStruct *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodLoginsPrimaryPasswordAuthenticatorOnAuthenticationSuccess>(
        aUniffiHandle,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerLoginsPrimaryPasswordAuthenticator);
}
/**
 * Callback method handler subclass for callback_interface_logins_primary_password_authenticator_on_authentication_failure
 *
 * This handles the specifics of the async call.
 * AsyncCallbackMethodHandlerBase::ScheduleAsyncCall handles the general parts.
 */
class CallbackInterfaceMethodLoginsPrimaryPasswordAuthenticatorOnAuthenticationFailure final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  ForeignFutureCompletevoid mUniffiCompleteCallback;
  uint64_t mUniffiCallbackData;

public:
  CallbackInterfaceMethodLoginsPrimaryPasswordAuthenticatorOnAuthenticationFailure(
      uint64_t aUniffiHandle,
      ForeignFutureCompletevoid aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData
  ) : AsyncCallbackMethodHandlerBase ("PrimaryPasswordAuthenticator.callback_interface_logins_primary_password_authenticator_on_authentication_failure", aUniffiHandle),
      mUniffiCompleteCallback(aUniffiCompleteCallback),
      mUniffiCallbackData(aUniffiCallbackData) { }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    // Convert arguments
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 2, uniffiArgs, aError);
    return result.forget();
  }

  void HandleReturn(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
                    ErrorResult& aRv) override {
    if (!mUniffiCompleteCallback) {
      MOZ_ASSERT_UNREACHABLE("HandleReturn called multiple times");
      return;
    }

    ForeignFutureResultVoid result{};
    CallbackLowerReturnVoid::Lower(aCallResult, &result.call_status, aRv);
    mUniffiCompleteCallback(mUniffiCallbackData, result);
    mUniffiCompleteCallback = nullptr;
  }

  ~CallbackInterfaceMethodLoginsPrimaryPasswordAuthenticatorOnAuthenticationFailure() {
    if (mUniffiCompleteCallback) {
      MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnVoid] promise never completed"));
      ForeignFutureResultVoid result{};
      result.call_status.code = RUST_CALL_INTERNAL_ERROR;
      mUniffiCompleteCallback(mUniffiCallbackData, result);
    }
  }
};

/**
 * callback_interface_logins_primary_password_authenticator_on_authentication_failure -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_logins_primary_password_authenticator_on_authentication_failure(
  uint64_t aUniffiHandle,
  ForeignFutureCompletevoid aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFutureDroppedCallbackStruct *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodLoginsPrimaryPasswordAuthenticatorOnAuthenticationFailure>(
        aUniffiHandle,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerLoginsPrimaryPasswordAuthenticator);
}

extern "C" void callback_free_logins_primary_password_authenticator(uint64_t aUniffiHandle) {
  if (CallbackHandleRelease(aUniffiHandle) == 0) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("PrimaryPasswordAuthenticator.uniffi_free", aUniffiHandle),
      &gUniffiCallbackHandlerLoginsPrimaryPasswordAuthenticator);
  }
}

extern "C" uint64_t callback_clone_logins_primary_password_authenticator(uint64_t aUniffiHandle) {
  CallbackHandleAddRef(aUniffiHandle);
  return aUniffiHandle;
}

static VTableCallbackInterfaceLoginsPrimaryPasswordAuthenticator kUniffiVtableLoginsPrimaryPasswordAuthenticator {
  callback_free_logins_primary_password_authenticator,
  callback_clone_logins_primary_password_authenticator,
  callback_interface_logins_primary_password_authenticator_get_primary_password,
  callback_interface_logins_primary_password_authenticator_on_authentication_success,
  callback_interface_logins_primary_password_authenticator_on_authentication_failure,
};
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerTracingEventSink;
/**
 * Callback method handler subclass for callback_interface_tracing_event_sink_on_event
 *
 * This is like the handler for an async function except:
 *
 * - It doesn't input the complete callback function/data
 * - It doesn't override HandleReturn and returns `nullptr` from MakeCall.
 *   This means ScheduleAsyncCall will schedule `MakeCall` and not do anything
 *   with the result, which is what we want.
 */
class CallbackInterfaceMethodTracingEventSinkOnEvent final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer mEvent{};

public:
  CallbackInterfaceMethodTracingEventSinkOnEvent(
      uint64_t aUniffiHandle,
      RustBuffer aEvent
  ) : AsyncCallbackMethodHandlerBase ("EventSink.callback_interface_tracing_event_sink_on_event", aUniffiHandle),
      mEvent(FfiValueRustBuffer::FromRust(aEvent)){ }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    // Convert arguments
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }
    mEvent.Lift(aCx, &uniffiArgs[0], aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 0, uniffiArgs, aError);
    return nullptr;
  }
};

/**
 * callback_interface_tracing_event_sink_on_event -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_tracing_event_sink_on_event(
  uint64_t aUniffiHandle,
  RustBuffer aEvent,
  void* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodTracingEventSinkOnEvent>(aUniffiHandle, aEvent);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerTracingEventSink);
}

extern "C" void callback_free_tracing_event_sink(uint64_t aUniffiHandle) {
  if (CallbackHandleRelease(aUniffiHandle) == 0) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("EventSink.uniffi_free", aUniffiHandle),
      &gUniffiCallbackHandlerTracingEventSink);
  }
}

extern "C" uint64_t callback_clone_tracing_event_sink(uint64_t aUniffiHandle) {
  CallbackHandleAddRef(aUniffiHandle);
  return aUniffiHandle;
}

static VTableCallbackInterfaceTracingEventSink kUniffiVtableTracingEventSink {
  callback_free_tracing_event_sink,
  callback_clone_tracing_event_sink,
  callback_interface_tracing_event_sink_on_event,
};
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerViaductBackend;
/**
 * Callback method handler subclass for callback_interface_viaduct_backend_send_request
 *
 * This handles the specifics of the async call.
 * AsyncCallbackMethodHandlerBase::ScheduleAsyncCall handles the general parts.
 */
class CallbackInterfaceMethodViaductBackendSendRequest final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer mRequest{};
  FfiValueRustBuffer mSettings{};
  ForeignFutureCompleterust_buffer mUniffiCompleteCallback;
  uint64_t mUniffiCallbackData;

public:
  CallbackInterfaceMethodViaductBackendSendRequest(
      uint64_t aUniffiHandle,
      RustBuffer aRequest,
      RustBuffer aSettings,
      ForeignFutureCompleterust_buffer aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData
  ) : AsyncCallbackMethodHandlerBase ("Backend.callback_interface_viaduct_backend_send_request", aUniffiHandle),
      mRequest(FfiValueRustBuffer::FromRust(aRequest)),
      mSettings(FfiValueRustBuffer::FromRust(aSettings)),
      mUniffiCompleteCallback(aUniffiCompleteCallback),
      mUniffiCallbackData(aUniffiCallbackData) { }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    // Convert arguments
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    if (!uniffiArgs.AppendElements(2, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }
    mRequest.Lift(aCx, &uniffiArgs[0], aError);
    if (aError.Failed()) {
      return nullptr;
    }
    mSettings.Lift(aCx, &uniffiArgs[1], aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 0, uniffiArgs, aError);
    return result.forget();
  }

  void HandleReturn(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
                    ErrorResult& aRv) override {
    if (!mUniffiCompleteCallback) {
      MOZ_ASSERT_UNREACHABLE("HandleReturn called multiple times");
      return;
    }

    ForeignFutureResultRustBuffer result{};
    result.return_value  = CallbackLowerReturnRustBuffer::Lower(aCallResult, &result.call_status, aRv);
    mUniffiCompleteCallback(mUniffiCallbackData, result);
    mUniffiCompleteCallback = nullptr;
  }

  ~CallbackInterfaceMethodViaductBackendSendRequest() {
    if (mUniffiCompleteCallback) {
      MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnRustBuffer] promise never completed"));
      ForeignFutureResultRustBuffer result{};
      result.call_status.code = RUST_CALL_INTERNAL_ERROR;
      mUniffiCompleteCallback(mUniffiCallbackData, result);
    }
  }
};

/**
 * callback_interface_viaduct_backend_send_request -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_viaduct_backend_send_request(
  uint64_t aUniffiHandle,
  RustBuffer aRequest,
  RustBuffer aSettings,
  ForeignFutureCompleterust_buffer aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFutureDroppedCallbackStruct *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodViaductBackendSendRequest>(
        aUniffiHandle,
        aRequest,
        aSettings,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerViaductBackend);
}

extern "C" void callback_free_viaduct_backend(uint64_t aUniffiHandle) {
  if (CallbackHandleRelease(aUniffiHandle) == 0) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("Backend.uniffi_free", aUniffiHandle),
      &gUniffiCallbackHandlerViaductBackend);
  }
}

extern "C" uint64_t callback_clone_viaduct_backend(uint64_t aUniffiHandle) {
  CallbackHandleAddRef(aUniffiHandle);
  return aUniffiHandle;
}

static VTableCallbackInterfaceViaductBackend kUniffiVtableViaductBackend {
  callback_free_viaduct_backend,
  callback_clone_viaduct_backend,
  callback_interface_viaduct_backend_send_request,
};

#ifdef MOZ_UNIFFI_FIXTURES
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface;
/**
 * Callback method handler subclass for callback_interface_uniffi_bindings_tests_test_async_callback_interface_noop
 *
 * This handles the specifics of the async call.
 * AsyncCallbackMethodHandlerBase::ScheduleAsyncCall handles the general parts.
 */
class CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceNoop final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  ForeignFutureCompletevoid mUniffiCompleteCallback;
  uint64_t mUniffiCallbackData;

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceNoop(
      uint64_t aUniffiHandle,
      ForeignFutureCompletevoid aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData
  ) : AsyncCallbackMethodHandlerBase ("TestAsyncCallbackInterface.callback_interface_uniffi_bindings_tests_test_async_callback_interface_noop", aUniffiHandle),
      mUniffiCompleteCallback(aUniffiCompleteCallback),
      mUniffiCallbackData(aUniffiCallbackData) { }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    // Convert arguments
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 0, uniffiArgs, aError);
    return result.forget();
  }

  void HandleReturn(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
                    ErrorResult& aRv) override {
    if (!mUniffiCompleteCallback) {
      MOZ_ASSERT_UNREACHABLE("HandleReturn called multiple times");
      return;
    }

    ForeignFutureResultVoid result{};
    CallbackLowerReturnVoid::Lower(aCallResult, &result.call_status, aRv);
    mUniffiCompleteCallback(mUniffiCallbackData, result);
    mUniffiCompleteCallback = nullptr;
  }

  ~CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceNoop() {
    if (mUniffiCompleteCallback) {
      MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnVoid] promise never completed"));
      ForeignFutureResultVoid result{};
      result.call_status.code = RUST_CALL_INTERNAL_ERROR;
      mUniffiCompleteCallback(mUniffiCallbackData, result);
    }
  }
};

/**
 * callback_interface_uniffi_bindings_tests_test_async_callback_interface_noop -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_test_async_callback_interface_noop(
  uint64_t aUniffiHandle,
  ForeignFutureCompletevoid aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFutureDroppedCallbackStruct *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceNoop>(
        aUniffiHandle,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface);
}
/**
 * Callback method handler subclass for callback_interface_uniffi_bindings_tests_test_async_callback_interface_get_value
 *
 * This handles the specifics of the async call.
 * AsyncCallbackMethodHandlerBase::ScheduleAsyncCall handles the general parts.
 */
class CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceGetValue final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  ForeignFutureCompleteu32 mUniffiCompleteCallback;
  uint64_t mUniffiCallbackData;

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceGetValue(
      uint64_t aUniffiHandle,
      ForeignFutureCompleteu32 aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData
  ) : AsyncCallbackMethodHandlerBase ("TestAsyncCallbackInterface.callback_interface_uniffi_bindings_tests_test_async_callback_interface_get_value", aUniffiHandle),
      mUniffiCompleteCallback(aUniffiCompleteCallback),
      mUniffiCallbackData(aUniffiCallbackData) { }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    // Convert arguments
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 1, uniffiArgs, aError);
    return result.forget();
  }

  void HandleReturn(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
                    ErrorResult& aRv) override {
    if (!mUniffiCompleteCallback) {
      MOZ_ASSERT_UNREACHABLE("HandleReturn called multiple times");
      return;
    }

    ForeignFutureResultU32 result{};
    result.return_value  = CallbackLowerReturnUInt32::Lower(aCallResult, &result.call_status, aRv);
    mUniffiCompleteCallback(mUniffiCallbackData, result);
    mUniffiCompleteCallback = nullptr;
  }

  ~CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceGetValue() {
    if (mUniffiCompleteCallback) {
      MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnUInt32] promise never completed"));
      ForeignFutureResultU32 result{};
      result.call_status.code = RUST_CALL_INTERNAL_ERROR;
      mUniffiCompleteCallback(mUniffiCallbackData, result);
    }
  }
};

/**
 * callback_interface_uniffi_bindings_tests_test_async_callback_interface_get_value -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_test_async_callback_interface_get_value(
  uint64_t aUniffiHandle,
  ForeignFutureCompleteu32 aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFutureDroppedCallbackStruct *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceGetValue>(
        aUniffiHandle,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface);
}
/**
 * Callback method handler subclass for callback_interface_uniffi_bindings_tests_test_async_callback_interface_set_value
 *
 * This handles the specifics of the async call.
 * AsyncCallbackMethodHandlerBase::ScheduleAsyncCall handles the general parts.
 */
class CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceSetValue final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueInt<uint32_t> mValue{};
  ForeignFutureCompletevoid mUniffiCompleteCallback;
  uint64_t mUniffiCallbackData;

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceSetValue(
      uint64_t aUniffiHandle,
      uint32_t aValue,
      ForeignFutureCompletevoid aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData
  ) : AsyncCallbackMethodHandlerBase ("TestAsyncCallbackInterface.callback_interface_uniffi_bindings_tests_test_async_callback_interface_set_value", aUniffiHandle),
      mValue(FfiValueInt<uint32_t>::FromRust(aValue)),
      mUniffiCompleteCallback(aUniffiCompleteCallback),
      mUniffiCallbackData(aUniffiCallbackData) { }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    // Convert arguments
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }
    mValue.Lift(aCx, &uniffiArgs[0], aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 2, uniffiArgs, aError);
    return result.forget();
  }

  void HandleReturn(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
                    ErrorResult& aRv) override {
    if (!mUniffiCompleteCallback) {
      MOZ_ASSERT_UNREACHABLE("HandleReturn called multiple times");
      return;
    }

    ForeignFutureResultVoid result{};
    CallbackLowerReturnVoid::Lower(aCallResult, &result.call_status, aRv);
    mUniffiCompleteCallback(mUniffiCallbackData, result);
    mUniffiCompleteCallback = nullptr;
  }

  ~CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceSetValue() {
    if (mUniffiCompleteCallback) {
      MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnVoid] promise never completed"));
      ForeignFutureResultVoid result{};
      result.call_status.code = RUST_CALL_INTERNAL_ERROR;
      mUniffiCompleteCallback(mUniffiCallbackData, result);
    }
  }
};

/**
 * callback_interface_uniffi_bindings_tests_test_async_callback_interface_set_value -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_test_async_callback_interface_set_value(
  uint64_t aUniffiHandle,
  uint32_t aValue,
  ForeignFutureCompletevoid aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFutureDroppedCallbackStruct *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceSetValue>(
        aUniffiHandle,
        aValue,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface);
}
/**
 * Callback method handler subclass for callback_interface_uniffi_bindings_tests_test_async_callback_interface_throw_if_equal
 *
 * This handles the specifics of the async call.
 * AsyncCallbackMethodHandlerBase::ScheduleAsyncCall handles the general parts.
 */
class CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceThrowIfEqual final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer mNumbers{};
  ForeignFutureCompleterust_buffer mUniffiCompleteCallback;
  uint64_t mUniffiCallbackData;

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceThrowIfEqual(
      uint64_t aUniffiHandle,
      RustBuffer aNumbers,
      ForeignFutureCompleterust_buffer aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData
  ) : AsyncCallbackMethodHandlerBase ("TestAsyncCallbackInterface.callback_interface_uniffi_bindings_tests_test_async_callback_interface_throw_if_equal", aUniffiHandle),
      mNumbers(FfiValueRustBuffer::FromRust(aNumbers)),
      mUniffiCompleteCallback(aUniffiCompleteCallback),
      mUniffiCallbackData(aUniffiCallbackData) { }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    // Convert arguments
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }
    mNumbers.Lift(aCx, &uniffiArgs[0], aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 3, uniffiArgs, aError);
    return result.forget();
  }

  void HandleReturn(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
                    ErrorResult& aRv) override {
    if (!mUniffiCompleteCallback) {
      MOZ_ASSERT_UNREACHABLE("HandleReturn called multiple times");
      return;
    }

    ForeignFutureResultRustBuffer result{};
    result.return_value  = CallbackLowerReturnRustBuffer::Lower(aCallResult, &result.call_status, aRv);
    mUniffiCompleteCallback(mUniffiCallbackData, result);
    mUniffiCompleteCallback = nullptr;
  }

  ~CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceThrowIfEqual() {
    if (mUniffiCompleteCallback) {
      MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnRustBuffer] promise never completed"));
      ForeignFutureResultRustBuffer result{};
      result.call_status.code = RUST_CALL_INTERNAL_ERROR;
      mUniffiCompleteCallback(mUniffiCallbackData, result);
    }
  }
};

/**
 * callback_interface_uniffi_bindings_tests_test_async_callback_interface_throw_if_equal -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_test_async_callback_interface_throw_if_equal(
  uint64_t aUniffiHandle,
  RustBuffer aNumbers,
  ForeignFutureCompleterust_buffer aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFutureDroppedCallbackStruct *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceThrowIfEqual>(
        aUniffiHandle,
        aNumbers,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface);
}

extern "C" void callback_free_uniffi_bindings_tests_test_async_callback_interface(uint64_t aUniffiHandle) {
  if (CallbackHandleRelease(aUniffiHandle) == 0) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("TestAsyncCallbackInterface.uniffi_free", aUniffiHandle),
      &gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface);
  }
}

extern "C" uint64_t callback_clone_uniffi_bindings_tests_test_async_callback_interface(uint64_t aUniffiHandle) {
  CallbackHandleAddRef(aUniffiHandle);
  return aUniffiHandle;
}

static VTableCallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterface kUniffiVtableUniffiBindingsTestsTestAsyncCallbackInterface {
  callback_free_uniffi_bindings_tests_test_async_callback_interface,
  callback_clone_uniffi_bindings_tests_test_async_callback_interface,
  callback_interface_uniffi_bindings_tests_test_async_callback_interface_noop,
  callback_interface_uniffi_bindings_tests_test_async_callback_interface_get_value,
  callback_interface_uniffi_bindings_tests_test_async_callback_interface_set_value,
  callback_interface_uniffi_bindings_tests_test_async_callback_interface_throw_if_equal,
};
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface;
/**
 * callback_interface_uniffi_bindings_tests_test_callback_interface_noop -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_test_callback_interface_noop(
  uint64_t aUniffiHandle,
  void* aUniffiOutReturn,
  RustCallStatus* aUniffiOutStatus
) {
  MOZ_RELEASE_ASSERT(NS_IsMainThread());
  // Take our own reference to the callback handler to ensure that it
  // stays alive for the duration of this call
  RefPtr<dom::UniFFICallbackHandler> jsHandler = gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface;
  // Create a JS context for the call
  JSObject* global = jsHandler->CallbackGlobalOrNull();
  if (!global) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_uniffi_bindings_tests_test_callback_interface_noop] JS handler has null global"));
    return;
  }
  dom::AutoEntryScript aes(global, "callback_interface_uniffi_bindings_tests_test_callback_interface_noop");

  // Convert arguments
  nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
  if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_uniffi_bindings_tests_test_callback_interface_noop] Failed to allocate arguments"));
    return;
  }
  IgnoredErrorResult error;

  RootedDictionary<UniFFIScaffoldingCallResult> callResult(aes.cx());
  jsHandler->CallSync(aUniffiHandle, 0, uniffiArgs, callResult, error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_uniffi_bindings_tests_test_callback_interface_noop] Error invoking JS handler"));
    return;
  }
  CallbackLowerReturnVoid::Lower(callResult, aUniffiOutStatus, error);
  }
/**
 * callback_interface_uniffi_bindings_tests_test_callback_interface_get_value -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_test_callback_interface_get_value(
  uint64_t aUniffiHandle,
  uint32_t* aUniffiOutReturn,
  RustCallStatus* aUniffiOutStatus
) {
  MOZ_RELEASE_ASSERT(NS_IsMainThread());
  // Take our own reference to the callback handler to ensure that it
  // stays alive for the duration of this call
  RefPtr<dom::UniFFICallbackHandler> jsHandler = gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface;
  // Create a JS context for the call
  JSObject* global = jsHandler->CallbackGlobalOrNull();
  if (!global) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_uniffi_bindings_tests_test_callback_interface_get_value] JS handler has null global"));
    return;
  }
  dom::AutoEntryScript aes(global, "callback_interface_uniffi_bindings_tests_test_callback_interface_get_value");

  // Convert arguments
  nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
  if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_uniffi_bindings_tests_test_callback_interface_get_value] Failed to allocate arguments"));
    return;
  }
  IgnoredErrorResult error;

  RootedDictionary<UniFFIScaffoldingCallResult> callResult(aes.cx());
  jsHandler->CallSync(aUniffiHandle, 1, uniffiArgs, callResult, error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_uniffi_bindings_tests_test_callback_interface_get_value] Error invoking JS handler"));
    return;
  }
  *aUniffiOutReturn = CallbackLowerReturnUInt32::Lower(callResult, aUniffiOutStatus, error);
  }
/**
 * callback_interface_uniffi_bindings_tests_test_callback_interface_set_value -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_test_callback_interface_set_value(
  uint64_t aUniffiHandle,
  uint32_t aValue,
  void* aUniffiOutReturn,
  RustCallStatus* aUniffiOutStatus
) {
  MOZ_RELEASE_ASSERT(NS_IsMainThread());
  // Take our own reference to the callback handler to ensure that it
  // stays alive for the duration of this call
  RefPtr<dom::UniFFICallbackHandler> jsHandler = gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface;
  // Create a JS context for the call
  JSObject* global = jsHandler->CallbackGlobalOrNull();
  if (!global) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_uniffi_bindings_tests_test_callback_interface_set_value] JS handler has null global"));
    return;
  }
  dom::AutoEntryScript aes(global, "callback_interface_uniffi_bindings_tests_test_callback_interface_set_value");

  // Convert arguments
  nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
  if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_uniffi_bindings_tests_test_callback_interface_set_value] Failed to allocate arguments"));
    return;
  }
  IgnoredErrorResult error;
  FfiValueInt<uint32_t> value = FfiValueInt<uint32_t>::FromRust(aValue);
  value.Lift(aes.cx(), &uniffiArgs[0], error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_uniffi_bindings_tests_test_callback_interface_set_value] Failed to lift aValue"));
    return;
  }

  RootedDictionary<UniFFIScaffoldingCallResult> callResult(aes.cx());
  jsHandler->CallSync(aUniffiHandle, 2, uniffiArgs, callResult, error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_uniffi_bindings_tests_test_callback_interface_set_value] Error invoking JS handler"));
    return;
  }
  CallbackLowerReturnVoid::Lower(callResult, aUniffiOutStatus, error);
  }
/**
 * callback_interface_uniffi_bindings_tests_test_callback_interface_throw_if_equal -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_test_callback_interface_throw_if_equal(
  uint64_t aUniffiHandle,
  RustBuffer aNumbers,
  RustBuffer* aUniffiOutReturn,
  RustCallStatus* aUniffiOutStatus
) {
  MOZ_RELEASE_ASSERT(NS_IsMainThread());
  // Take our own reference to the callback handler to ensure that it
  // stays alive for the duration of this call
  RefPtr<dom::UniFFICallbackHandler> jsHandler = gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface;
  // Create a JS context for the call
  JSObject* global = jsHandler->CallbackGlobalOrNull();
  if (!global) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_uniffi_bindings_tests_test_callback_interface_throw_if_equal] JS handler has null global"));
    return;
  }
  dom::AutoEntryScript aes(global, "callback_interface_uniffi_bindings_tests_test_callback_interface_throw_if_equal");

  // Convert arguments
  nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
  if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_uniffi_bindings_tests_test_callback_interface_throw_if_equal] Failed to allocate arguments"));
    return;
  }
  IgnoredErrorResult error;
  FfiValueRustBuffer numbers = FfiValueRustBuffer::FromRust(aNumbers);
  numbers.Lift(aes.cx(), &uniffiArgs[0], error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_uniffi_bindings_tests_test_callback_interface_throw_if_equal] Failed to lift aNumbers"));
    return;
  }

  RootedDictionary<UniFFIScaffoldingCallResult> callResult(aes.cx());
  jsHandler->CallSync(aUniffiHandle, 3, uniffiArgs, callResult, error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_uniffi_bindings_tests_test_callback_interface_throw_if_equal] Error invoking JS handler"));
    return;
  }
  *aUniffiOutReturn = CallbackLowerReturnRustBuffer::Lower(callResult, aUniffiOutStatus, error);
  }

extern "C" void callback_free_uniffi_bindings_tests_test_callback_interface(uint64_t aUniffiHandle) {
  if (CallbackHandleRelease(aUniffiHandle) == 0) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("TestCallbackInterface.uniffi_free", aUniffiHandle),
      &gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface);
  }
}

extern "C" uint64_t callback_clone_uniffi_bindings_tests_test_callback_interface(uint64_t aUniffiHandle) {
  CallbackHandleAddRef(aUniffiHandle);
  return aUniffiHandle;
}

static VTableCallbackInterfaceUniffiBindingsTestsTestCallbackInterface kUniffiVtableUniffiBindingsTestsTestCallbackInterface {
  callback_free_uniffi_bindings_tests_test_callback_interface,
  callback_clone_uniffi_bindings_tests_test_callback_interface,
  callback_interface_uniffi_bindings_tests_test_callback_interface_noop,
  callback_interface_uniffi_bindings_tests_test_callback_interface_get_value,
  callback_interface_uniffi_bindings_tests_test_callback_interface_set_value,
  callback_interface_uniffi_bindings_tests_test_callback_interface_throw_if_equal,
};
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface;
/**
 * Callback method handler subclass for callback_interface_uniffi_bindings_tests_async_test_trait_interface_noop
 *
 * This handles the specifics of the async call.
 * AsyncCallbackMethodHandlerBase::ScheduleAsyncCall handles the general parts.
 */
class CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceNoop final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  ForeignFutureCompletevoid mUniffiCompleteCallback;
  uint64_t mUniffiCallbackData;

public:
  CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceNoop(
      uint64_t aUniffiHandle,
      ForeignFutureCompletevoid aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData
  ) : AsyncCallbackMethodHandlerBase ("AsyncTestTraitInterface.callback_interface_uniffi_bindings_tests_async_test_trait_interface_noop", aUniffiHandle),
      mUniffiCompleteCallback(aUniffiCompleteCallback),
      mUniffiCallbackData(aUniffiCallbackData) { }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    // Convert arguments
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 0, uniffiArgs, aError);
    return result.forget();
  }

  void HandleReturn(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
                    ErrorResult& aRv) override {
    if (!mUniffiCompleteCallback) {
      MOZ_ASSERT_UNREACHABLE("HandleReturn called multiple times");
      return;
    }

    ForeignFutureResultVoid result{};
    CallbackLowerReturnVoid::Lower(aCallResult, &result.call_status, aRv);
    mUniffiCompleteCallback(mUniffiCallbackData, result);
    mUniffiCompleteCallback = nullptr;
  }

  ~CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceNoop() {
    if (mUniffiCompleteCallback) {
      MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnVoid] promise never completed"));
      ForeignFutureResultVoid result{};
      result.call_status.code = RUST_CALL_INTERNAL_ERROR;
      mUniffiCompleteCallback(mUniffiCallbackData, result);
    }
  }
};

/**
 * callback_interface_uniffi_bindings_tests_async_test_trait_interface_noop -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_async_test_trait_interface_noop(
  uint64_t aUniffiHandle,
  ForeignFutureCompletevoid aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFutureDroppedCallbackStruct *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceNoop>(
        aUniffiHandle,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface);
}
/**
 * Callback method handler subclass for callback_interface_uniffi_bindings_tests_async_test_trait_interface_get_value
 *
 * This handles the specifics of the async call.
 * AsyncCallbackMethodHandlerBase::ScheduleAsyncCall handles the general parts.
 */
class CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceGetValue final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  ForeignFutureCompleteu32 mUniffiCompleteCallback;
  uint64_t mUniffiCallbackData;

public:
  CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceGetValue(
      uint64_t aUniffiHandle,
      ForeignFutureCompleteu32 aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData
  ) : AsyncCallbackMethodHandlerBase ("AsyncTestTraitInterface.callback_interface_uniffi_bindings_tests_async_test_trait_interface_get_value", aUniffiHandle),
      mUniffiCompleteCallback(aUniffiCompleteCallback),
      mUniffiCallbackData(aUniffiCallbackData) { }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    // Convert arguments
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 1, uniffiArgs, aError);
    return result.forget();
  }

  void HandleReturn(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
                    ErrorResult& aRv) override {
    if (!mUniffiCompleteCallback) {
      MOZ_ASSERT_UNREACHABLE("HandleReturn called multiple times");
      return;
    }

    ForeignFutureResultU32 result{};
    result.return_value  = CallbackLowerReturnUInt32::Lower(aCallResult, &result.call_status, aRv);
    mUniffiCompleteCallback(mUniffiCallbackData, result);
    mUniffiCompleteCallback = nullptr;
  }

  ~CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceGetValue() {
    if (mUniffiCompleteCallback) {
      MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnUInt32] promise never completed"));
      ForeignFutureResultU32 result{};
      result.call_status.code = RUST_CALL_INTERNAL_ERROR;
      mUniffiCompleteCallback(mUniffiCallbackData, result);
    }
  }
};

/**
 * callback_interface_uniffi_bindings_tests_async_test_trait_interface_get_value -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_async_test_trait_interface_get_value(
  uint64_t aUniffiHandle,
  ForeignFutureCompleteu32 aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFutureDroppedCallbackStruct *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceGetValue>(
        aUniffiHandle,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface);
}
/**
 * Callback method handler subclass for callback_interface_uniffi_bindings_tests_async_test_trait_interface_set_value
 *
 * This handles the specifics of the async call.
 * AsyncCallbackMethodHandlerBase::ScheduleAsyncCall handles the general parts.
 */
class CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceSetValue final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueInt<uint32_t> mValue{};
  ForeignFutureCompletevoid mUniffiCompleteCallback;
  uint64_t mUniffiCallbackData;

public:
  CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceSetValue(
      uint64_t aUniffiHandle,
      uint32_t aValue,
      ForeignFutureCompletevoid aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData
  ) : AsyncCallbackMethodHandlerBase ("AsyncTestTraitInterface.callback_interface_uniffi_bindings_tests_async_test_trait_interface_set_value", aUniffiHandle),
      mValue(FfiValueInt<uint32_t>::FromRust(aValue)),
      mUniffiCompleteCallback(aUniffiCompleteCallback),
      mUniffiCallbackData(aUniffiCallbackData) { }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    // Convert arguments
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }
    mValue.Lift(aCx, &uniffiArgs[0], aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 2, uniffiArgs, aError);
    return result.forget();
  }

  void HandleReturn(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
                    ErrorResult& aRv) override {
    if (!mUniffiCompleteCallback) {
      MOZ_ASSERT_UNREACHABLE("HandleReturn called multiple times");
      return;
    }

    ForeignFutureResultVoid result{};
    CallbackLowerReturnVoid::Lower(aCallResult, &result.call_status, aRv);
    mUniffiCompleteCallback(mUniffiCallbackData, result);
    mUniffiCompleteCallback = nullptr;
  }

  ~CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceSetValue() {
    if (mUniffiCompleteCallback) {
      MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnVoid] promise never completed"));
      ForeignFutureResultVoid result{};
      result.call_status.code = RUST_CALL_INTERNAL_ERROR;
      mUniffiCompleteCallback(mUniffiCallbackData, result);
    }
  }
};

/**
 * callback_interface_uniffi_bindings_tests_async_test_trait_interface_set_value -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_async_test_trait_interface_set_value(
  uint64_t aUniffiHandle,
  uint32_t aValue,
  ForeignFutureCompletevoid aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFutureDroppedCallbackStruct *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceSetValue>(
        aUniffiHandle,
        aValue,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface);
}
/**
 * Callback method handler subclass for callback_interface_uniffi_bindings_tests_async_test_trait_interface_throw_if_equal
 *
 * This handles the specifics of the async call.
 * AsyncCallbackMethodHandlerBase::ScheduleAsyncCall handles the general parts.
 */
class CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceThrowIfEqual final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer mNumbers{};
  ForeignFutureCompleterust_buffer mUniffiCompleteCallback;
  uint64_t mUniffiCallbackData;

public:
  CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceThrowIfEqual(
      uint64_t aUniffiHandle,
      RustBuffer aNumbers,
      ForeignFutureCompleterust_buffer aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData
  ) : AsyncCallbackMethodHandlerBase ("AsyncTestTraitInterface.callback_interface_uniffi_bindings_tests_async_test_trait_interface_throw_if_equal", aUniffiHandle),
      mNumbers(FfiValueRustBuffer::FromRust(aNumbers)),
      mUniffiCompleteCallback(aUniffiCompleteCallback),
      mUniffiCallbackData(aUniffiCallbackData) { }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    // Convert arguments
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }
    mNumbers.Lift(aCx, &uniffiArgs[0], aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 3, uniffiArgs, aError);
    return result.forget();
  }

  void HandleReturn(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
                    ErrorResult& aRv) override {
    if (!mUniffiCompleteCallback) {
      MOZ_ASSERT_UNREACHABLE("HandleReturn called multiple times");
      return;
    }

    ForeignFutureResultRustBuffer result{};
    result.return_value  = CallbackLowerReturnRustBuffer::Lower(aCallResult, &result.call_status, aRv);
    mUniffiCompleteCallback(mUniffiCallbackData, result);
    mUniffiCompleteCallback = nullptr;
  }

  ~CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceThrowIfEqual() {
    if (mUniffiCompleteCallback) {
      MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[CallbackLowerReturnRustBuffer] promise never completed"));
      ForeignFutureResultRustBuffer result{};
      result.call_status.code = RUST_CALL_INTERNAL_ERROR;
      mUniffiCompleteCallback(mUniffiCallbackData, result);
    }
  }
};

/**
 * callback_interface_uniffi_bindings_tests_async_test_trait_interface_throw_if_equal -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_async_test_trait_interface_throw_if_equal(
  uint64_t aUniffiHandle,
  RustBuffer aNumbers,
  ForeignFutureCompleterust_buffer aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFutureDroppedCallbackStruct *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceThrowIfEqual>(
        aUniffiHandle,
        aNumbers,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface);
}

extern "C" void callback_free_uniffi_bindings_tests_async_test_trait_interface(uint64_t aUniffiHandle) {
  if (CallbackHandleRelease(aUniffiHandle) == 0) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("AsyncTestTraitInterface.uniffi_free", aUniffiHandle),
      &gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface);
  }
}

extern "C" uint64_t callback_clone_uniffi_bindings_tests_async_test_trait_interface(uint64_t aUniffiHandle) {
  CallbackHandleAddRef(aUniffiHandle);
  return aUniffiHandle;
}

static VTableCallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterface kUniffiVtableUniffiBindingsTestsAsyncTestTraitInterface {
  callback_free_uniffi_bindings_tests_async_test_trait_interface,
  callback_clone_uniffi_bindings_tests_async_test_trait_interface,
  callback_interface_uniffi_bindings_tests_async_test_trait_interface_noop,
  callback_interface_uniffi_bindings_tests_async_test_trait_interface_get_value,
  callback_interface_uniffi_bindings_tests_async_test_trait_interface_set_value,
  callback_interface_uniffi_bindings_tests_async_test_trait_interface_throw_if_equal,
};
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface;
/**
 * callback_interface_uniffi_bindings_tests_test_trait_interface_noop -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_test_trait_interface_noop(
  uint64_t aUniffiHandle,
  void* aUniffiOutReturn,
  RustCallStatus* aUniffiOutStatus
) {
  MOZ_RELEASE_ASSERT(NS_IsMainThread());
  // Take our own reference to the callback handler to ensure that it
  // stays alive for the duration of this call
  RefPtr<dom::UniFFICallbackHandler> jsHandler = gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface;
  // Create a JS context for the call
  JSObject* global = jsHandler->CallbackGlobalOrNull();
  if (!global) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_uniffi_bindings_tests_test_trait_interface_noop] JS handler has null global"));
    return;
  }
  dom::AutoEntryScript aes(global, "callback_interface_uniffi_bindings_tests_test_trait_interface_noop");

  // Convert arguments
  nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
  if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_uniffi_bindings_tests_test_trait_interface_noop] Failed to allocate arguments"));
    return;
  }
  IgnoredErrorResult error;

  RootedDictionary<UniFFIScaffoldingCallResult> callResult(aes.cx());
  jsHandler->CallSync(aUniffiHandle, 0, uniffiArgs, callResult, error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_uniffi_bindings_tests_test_trait_interface_noop] Error invoking JS handler"));
    return;
  }
  CallbackLowerReturnVoid::Lower(callResult, aUniffiOutStatus, error);
  }
/**
 * callback_interface_uniffi_bindings_tests_test_trait_interface_get_value -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_test_trait_interface_get_value(
  uint64_t aUniffiHandle,
  uint32_t* aUniffiOutReturn,
  RustCallStatus* aUniffiOutStatus
) {
  MOZ_RELEASE_ASSERT(NS_IsMainThread());
  // Take our own reference to the callback handler to ensure that it
  // stays alive for the duration of this call
  RefPtr<dom::UniFFICallbackHandler> jsHandler = gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface;
  // Create a JS context for the call
  JSObject* global = jsHandler->CallbackGlobalOrNull();
  if (!global) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_uniffi_bindings_tests_test_trait_interface_get_value] JS handler has null global"));
    return;
  }
  dom::AutoEntryScript aes(global, "callback_interface_uniffi_bindings_tests_test_trait_interface_get_value");

  // Convert arguments
  nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
  if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_uniffi_bindings_tests_test_trait_interface_get_value] Failed to allocate arguments"));
    return;
  }
  IgnoredErrorResult error;

  RootedDictionary<UniFFIScaffoldingCallResult> callResult(aes.cx());
  jsHandler->CallSync(aUniffiHandle, 1, uniffiArgs, callResult, error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_uniffi_bindings_tests_test_trait_interface_get_value] Error invoking JS handler"));
    return;
  }
  *aUniffiOutReturn = CallbackLowerReturnUInt32::Lower(callResult, aUniffiOutStatus, error);
  }
/**
 * callback_interface_uniffi_bindings_tests_test_trait_interface_set_value -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_test_trait_interface_set_value(
  uint64_t aUniffiHandle,
  uint32_t aValue,
  void* aUniffiOutReturn,
  RustCallStatus* aUniffiOutStatus
) {
  MOZ_RELEASE_ASSERT(NS_IsMainThread());
  // Take our own reference to the callback handler to ensure that it
  // stays alive for the duration of this call
  RefPtr<dom::UniFFICallbackHandler> jsHandler = gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface;
  // Create a JS context for the call
  JSObject* global = jsHandler->CallbackGlobalOrNull();
  if (!global) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_uniffi_bindings_tests_test_trait_interface_set_value] JS handler has null global"));
    return;
  }
  dom::AutoEntryScript aes(global, "callback_interface_uniffi_bindings_tests_test_trait_interface_set_value");

  // Convert arguments
  nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
  if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_uniffi_bindings_tests_test_trait_interface_set_value] Failed to allocate arguments"));
    return;
  }
  IgnoredErrorResult error;
  FfiValueInt<uint32_t> value = FfiValueInt<uint32_t>::FromRust(aValue);
  value.Lift(aes.cx(), &uniffiArgs[0], error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_uniffi_bindings_tests_test_trait_interface_set_value] Failed to lift aValue"));
    return;
  }

  RootedDictionary<UniFFIScaffoldingCallResult> callResult(aes.cx());
  jsHandler->CallSync(aUniffiHandle, 2, uniffiArgs, callResult, error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_uniffi_bindings_tests_test_trait_interface_set_value] Error invoking JS handler"));
    return;
  }
  CallbackLowerReturnVoid::Lower(callResult, aUniffiOutStatus, error);
  }
/**
 * callback_interface_uniffi_bindings_tests_test_trait_interface_throw_if_equal -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_test_trait_interface_throw_if_equal(
  uint64_t aUniffiHandle,
  RustBuffer aNumbers,
  RustBuffer* aUniffiOutReturn,
  RustCallStatus* aUniffiOutStatus
) {
  MOZ_RELEASE_ASSERT(NS_IsMainThread());
  // Take our own reference to the callback handler to ensure that it
  // stays alive for the duration of this call
  RefPtr<dom::UniFFICallbackHandler> jsHandler = gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface;
  // Create a JS context for the call
  JSObject* global = jsHandler->CallbackGlobalOrNull();
  if (!global) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_uniffi_bindings_tests_test_trait_interface_throw_if_equal] JS handler has null global"));
    return;
  }
  dom::AutoEntryScript aes(global, "callback_interface_uniffi_bindings_tests_test_trait_interface_throw_if_equal");

  // Convert arguments
  nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
  if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
    MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[callback_interface_uniffi_bindings_tests_test_trait_interface_throw_if_equal] Failed to allocate arguments"));
    return;
  }
  IgnoredErrorResult error;
  FfiValueRustBuffer numbers = FfiValueRustBuffer::FromRust(aNumbers);
  numbers.Lift(aes.cx(), &uniffiArgs[0], error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_uniffi_bindings_tests_test_trait_interface_throw_if_equal] Failed to lift aNumbers"));
    return;
  }

  RootedDictionary<UniFFIScaffoldingCallResult> callResult(aes.cx());
  jsHandler->CallSync(aUniffiHandle, 3, uniffiArgs, callResult, error);
  if (error.Failed()) {
    MOZ_LOG(
        gUniffiLogger, LogLevel::Error,
        ("[callback_interface_uniffi_bindings_tests_test_trait_interface_throw_if_equal] Error invoking JS handler"));
    return;
  }
  *aUniffiOutReturn = CallbackLowerReturnRustBuffer::Lower(callResult, aUniffiOutStatus, error);
  }

extern "C" void callback_free_uniffi_bindings_tests_test_trait_interface(uint64_t aUniffiHandle) {
  if (CallbackHandleRelease(aUniffiHandle) == 0) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("TestTraitInterface.uniffi_free", aUniffiHandle),
      &gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface);
  }
}

extern "C" uint64_t callback_clone_uniffi_bindings_tests_test_trait_interface(uint64_t aUniffiHandle) {
  CallbackHandleAddRef(aUniffiHandle);
  return aUniffiHandle;
}

static VTableCallbackInterfaceUniffiBindingsTestsTestTraitInterface kUniffiVtableUniffiBindingsTestsTestTraitInterface {
  callback_free_uniffi_bindings_tests_test_trait_interface,
  callback_clone_uniffi_bindings_tests_test_trait_interface,
  callback_interface_uniffi_bindings_tests_test_trait_interface_noop,
  callback_interface_uniffi_bindings_tests_test_trait_interface_get_value,
  callback_interface_uniffi_bindings_tests_test_trait_interface_set_value,
  callback_interface_uniffi_bindings_tests_test_trait_interface_throw_if_equal,
};
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerUniffiBindingsTestsCollisionTestCallbackInterface;
/**
 * Callback method handler subclass for callback_interface_uniffi_bindings_tests_collision_test_callback_interface_get_value
 *
 * This is like the handler for an async function except:
 *
 * - It doesn't input the complete callback function/data
 * - It doesn't override HandleReturn and returns `nullptr` from MakeCall.
 *   This means ScheduleAsyncCall will schedule `MakeCall` and not do anything
 *   with the result, which is what we want.
 */
class CallbackInterfaceMethodUniffiBindingsTestsCollisionTestCallbackInterfaceGetValue final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments

public:
  CallbackInterfaceMethodUniffiBindingsTestsCollisionTestCallbackInterfaceGetValue(
      uint64_t aUniffiHandle
  ) : AsyncCallbackMethodHandlerBase ("TestCallbackInterface.callback_interface_uniffi_bindings_tests_collision_test_callback_interface_get_value", aUniffiHandle){ }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    // Convert arguments
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 0, uniffiArgs, aError);
    return nullptr;
  }
};

/**
 * callback_interface_uniffi_bindings_tests_collision_test_callback_interface_get_value -- C function to handle the callback method
 *
 * This is what Rust calls when it invokes a callback method.
 */
extern "C" void callback_interface_uniffi_bindings_tests_collision_test_callback_interface_get_value(
  uint64_t aUniffiHandle,
  RustBuffer* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsCollisionTestCallbackInterfaceGetValue>(aUniffiHandle);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsCollisionTestCallbackInterface);
}

extern "C" void callback_free_uniffi_bindings_tests_collision_test_callback_interface(uint64_t aUniffiHandle) {
  if (CallbackHandleRelease(aUniffiHandle) == 0) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("TestCallbackInterface.uniffi_free", aUniffiHandle),
      &gUniffiCallbackHandlerUniffiBindingsTestsCollisionTestCallbackInterface);
  }
}

extern "C" uint64_t callback_clone_uniffi_bindings_tests_collision_test_callback_interface(uint64_t aUniffiHandle) {
  CallbackHandleAddRef(aUniffiHandle);
  return aUniffiHandle;
}

static VTableCallbackInterfaceUniffiBindingsTestsCollisionTestCallbackInterface kUniffiVtableUniffiBindingsTestsCollisionTestCallbackInterface {
  callback_free_uniffi_bindings_tests_collision_test_callback_interface,
  callback_clone_uniffi_bindings_tests_collision_test_callback_interface,
  callback_interface_uniffi_bindings_tests_collision_test_callback_interface_get_value,
};
#endif /* MOZ_UNIFFI_FIXTURES */

void RegisterCallbackHandler(uint64_t aInterfaceId, UniFFICallbackHandler& aCallbackHandler, ErrorResult& aError) {
  switch (aInterfaceId) {
    
    case 1: {
      if (gUniffiCallbackHandlerContextIdContextIdCallback) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for ContextIdCallback"_ns);
        return;
      }

      gUniffiCallbackHandlerContextIdContextIdCallback = &aCallbackHandler;
      uniffi_context_id_fn_init_callback_vtable_contextidcallback(&kUniffiVtableContextIdContextIdCallback);
      break;
    }
    case 2: {
      if (gUniffiCallbackHandlerLoginsEncryptorDecryptor) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for EncryptorDecryptor"_ns);
        return;
      }

      gUniffiCallbackHandlerLoginsEncryptorDecryptor = &aCallbackHandler;
      uniffi_logins_fn_init_callback_vtable_encryptordecryptor(&kUniffiVtableLoginsEncryptorDecryptor);
      break;
    }
    case 3: {
      if (gUniffiCallbackHandlerLoginsKeyManager) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for KeyManager"_ns);
        return;
      }

      gUniffiCallbackHandlerLoginsKeyManager = &aCallbackHandler;
      uniffi_logins_fn_init_callback_vtable_keymanager(&kUniffiVtableLoginsKeyManager);
      break;
    }
    case 4: {
      if (gUniffiCallbackHandlerLoginsPrimaryPasswordAuthenticator) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for PrimaryPasswordAuthenticator"_ns);
        return;
      }

      gUniffiCallbackHandlerLoginsPrimaryPasswordAuthenticator = &aCallbackHandler;
      uniffi_logins_fn_init_callback_vtable_primarypasswordauthenticator(&kUniffiVtableLoginsPrimaryPasswordAuthenticator);
      break;
    }
    case 5: {
      if (gUniffiCallbackHandlerTracingEventSink) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for EventSink"_ns);
        return;
      }

      gUniffiCallbackHandlerTracingEventSink = &aCallbackHandler;
      uniffi_tracing_support_fn_init_callback_vtable_eventsink(&kUniffiVtableTracingEventSink);
      break;
    }
    case 6: {
      if (gUniffiCallbackHandlerViaductBackend) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for Backend"_ns);
        return;
      }

      gUniffiCallbackHandlerViaductBackend = &aCallbackHandler;
      uniffi_viaduct_fn_init_callback_vtable_backend(&kUniffiVtableViaductBackend);
      break;
    }
    
    #ifdef MOZ_UNIFFI_FIXTURES
    case 7: {
      if (gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for TestAsyncCallbackInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface = &aCallbackHandler;
      uniffi_uniffi_bindings_tests_fn_init_callback_vtable_testasynccallbackinterface(&kUniffiVtableUniffiBindingsTestsTestAsyncCallbackInterface);
      break;
    }
    case 8: {
      if (gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for TestCallbackInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface = &aCallbackHandler;
      uniffi_uniffi_bindings_tests_fn_init_callback_vtable_testcallbackinterface(&kUniffiVtableUniffiBindingsTestsTestCallbackInterface);
      break;
    }
    case 9: {
      if (gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for AsyncTestTraitInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface = &aCallbackHandler;
      uniffi_uniffi_bindings_tests_fn_init_callback_vtable_asynctesttraitinterface(&kUniffiVtableUniffiBindingsTestsAsyncTestTraitInterface);
      break;
    }
    case 10: {
      if (gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for TestTraitInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface = &aCallbackHandler;
      uniffi_uniffi_bindings_tests_fn_init_callback_vtable_testtraitinterface(&kUniffiVtableUniffiBindingsTestsTestTraitInterface);
      break;
    }
    case 11: {
      if (gUniffiCallbackHandlerUniffiBindingsTestsCollisionTestCallbackInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for TestCallbackInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsCollisionTestCallbackInterface = &aCallbackHandler;
      uniffi_uniffi_bindings_tests_collision_fn_init_callback_vtable_testcallbackinterface(&kUniffiVtableUniffiBindingsTestsCollisionTestCallbackInterface);
      break;
    }
    #endif /* MOZ_UNIFFI_FIXTURES */

    default:
      aError.ThrowUnknownError(nsPrintfCString("RegisterCallbackHandler: Unknown callback interface id (%" PRIu64 ")", aInterfaceId));
      return;
  }
}

void DeregisterCallbackHandler(uint64_t aInterfaceId, ErrorResult& aError) {
  switch (aInterfaceId) {
    
    case 1: {
      if (!gUniffiCallbackHandlerContextIdContextIdCallback) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for ContextIdCallback"_ns);
        return;
      }

      gUniffiCallbackHandlerContextIdContextIdCallback = nullptr;
      break;
    }
    case 2: {
      if (!gUniffiCallbackHandlerLoginsEncryptorDecryptor) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for EncryptorDecryptor"_ns);
        return;
      }

      gUniffiCallbackHandlerLoginsEncryptorDecryptor = nullptr;
      break;
    }
    case 3: {
      if (!gUniffiCallbackHandlerLoginsKeyManager) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for KeyManager"_ns);
        return;
      }

      gUniffiCallbackHandlerLoginsKeyManager = nullptr;
      break;
    }
    case 4: {
      if (!gUniffiCallbackHandlerLoginsPrimaryPasswordAuthenticator) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for PrimaryPasswordAuthenticator"_ns);
        return;
      }

      gUniffiCallbackHandlerLoginsPrimaryPasswordAuthenticator = nullptr;
      break;
    }
    case 5: {
      if (!gUniffiCallbackHandlerTracingEventSink) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for EventSink"_ns);
        return;
      }

      gUniffiCallbackHandlerTracingEventSink = nullptr;
      break;
    }
    case 6: {
      if (!gUniffiCallbackHandlerViaductBackend) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for Backend"_ns);
        return;
      }

      gUniffiCallbackHandlerViaductBackend = nullptr;
      break;
    }
    
    #ifdef MOZ_UNIFFI_FIXTURES
    case 7: {
      if (!gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for TestAsyncCallbackInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface = nullptr;
      break;
    }
    case 8: {
      if (!gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for TestCallbackInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface = nullptr;
      break;
    }
    case 9: {
      if (!gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for AsyncTestTraitInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface = nullptr;
      break;
    }
    case 10: {
      if (!gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for TestTraitInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface = nullptr;
      break;
    }
    case 11: {
      if (!gUniffiCallbackHandlerUniffiBindingsTestsCollisionTestCallbackInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for TestCallbackInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsCollisionTestCallbackInterface = nullptr;
      break;
    }
    #endif /* MOZ_UNIFFI_FIXTURES */

    default:
      aError.ThrowUnknownError(nsPrintfCString("DeregisterCallbackHandler: Unknown callback interface id (%" PRIu64 ")", aInterfaceId));
      return;
  }
}

}  // namespace mozilla::uniffi
