<!doctype html>
<html>
<head>
  <title>Test content script at data:-URLs</title>
  <script src="/tests/SimpleTest/SimpleTest.js"></script>
  <script src="/tests/SimpleTest/ExtensionTestUtils.js"></script>
  <script src="head.js"></script>
  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
</head>
<body>

<script type="text/javascript">
"use strict";

// Test that match_about_blank does NOT match data: URL iframes.
// The "top-level special case" from bug 1451463 only applies to top-level
// data: URLs, not iframes. This test verifies that match_about_blank content
// scripts don't incorrectly inject into data: URL iframes.
add_task(async function data_url_iframe_match_about_blank_does_not_match() {
  const manifest = {
    content_scripts: [
      {
        // match_about_blank is documented to match the parent URL for
        // about:blank / about:srcdoc, which inherit the parent principal.
        // data:-URLs do not inherit the principal (bug 1324406), so this
        // should NOT match data: URL iframes.
        match_about_blank: true,
        // This HTML file is the test itself, which loads the iframe.
        matches: ["*://*/*/test_ext_contentscript_data_url.html"],
        all_frames: true,
        js: ["match_about_blank:matches.js"],
        run_at: "document_start",
      }, {
        // The special case for top-level data: URLs (bug 1451463) does not
        // apply to iframes, so this should NOT match data: URL iframes.
        match_about_blank: true,
        matches: ["*://*/*"],
        js: ["match_about_blank:wildcard.js"],
        all_frames: true,
        run_at: "document_start",
      }, {
        // Sanity check: without matching matches, this should never match.
        match_about_blank: true,
        matches: ["*://*/never_matched"],
        all_frames: true,
        js: ["never_matched.js"],
        run_at: "document_start",
      }, {
        // Use match_origin_as_fallback to signal when content scripts have
        // had a chance to run on the data: URL iframe.
        match_origin_as_fallback: true,
        matches: ["*://mochi.test/*"],
        all_frames: true,
        js: ["signal_loaded.js"],
        run_at: "document_idle",
      },
    ],
  };

  const files = {
    "match_about_blank:matches.js": () => {
      if (location.protocol === "data:") {
        browser.test.fail(`Unexpectedly matched match_about_blank:matches at ${location.href}`);
      }
    },
    "match_about_blank:wildcard.js": () => {
      if (location.protocol === "data:") {
        browser.test.fail(`Unexpectedly matched match_about_blank:wildcard at ${location.href}`);
      }
    },
    "never_matched.js": () => {
      browser.test.fail(`Unexpected match at: ${location.href}`);
    },
    "signal_loaded.js": () => {
      if (location.href === "data:,iframe_data") {
        browser.test.sendMessage("data_frame_loaded", location.href);
      }
    },
  };

  const extension = ExtensionTestUtils.loadExtension({ manifest, files });
  await extension.startup();

  // Test with nested data: URLs to confirm match_about_blank doesn't match either.
  // signal_loaded (with match_origin_as_fallback) tells us when done.
  const DATA_URL_FRAME = "data:,iframe_data";
  const DATA_URL = `data:text/html,<iframe src="${DATA_URL_FRAME}"></iframe>`;

  let frame = document.createElement("iframe");
  frame.src = DATA_URL;
  document.body.appendChild(frame);

  // Wait for signal that content scripts have run. If match_about_blank
  // scripts had incorrectly matched, they would have called fail() above.
  let loadedUrl = await extension.awaitMessage("data_frame_loaded");
  is(loadedUrl, DATA_URL_FRAME, "signal_loaded ran on nested data: URL iframe via match_origin_as_fallback");

  frame.remove();

  await extension.unload();
});

// Test that match_origin_as_fallback matches data: URL iframes based on
// the precursor (parent page) origin.
add_task(async function data_url_iframe_via_match_origin_as_fallback() {
  const manifest = {
    content_scripts: [
      {
        match_origin_as_fallback: true,
        // mochi.test is where the test is running from (the parent page).
        matches: ["*://mochi.test/*"],
        all_frames: true,
        js: ["matched_fallback:host.js"],
        run_at: "document_start",
      }, {
        // When a data:-URL has a precursor (the parent page's origin),
        // matching is based on that origin. include_globs matches the origin.
        match_origin_as_fallback: true,
        matches: ["*://mochi.test/*"],
        include_globs: ["http*"], // matches http://mochi.test:8888
        all_frames: true,
        js: ["matched_fallback:glob.js"],
        run_at: "document_start",
      }, {
        // Sanity check: without matching matches, this should never match.
        match_origin_as_fallback: true,
        matches: ["*://*/never_matched"],
        all_frames: true,
        js: ["never_matched.js"],
        run_at: "document_start",
      },
    ],
  };

  const files = {
    "matched_fallback:host.js": () => {
      if (location.protocol === "data:") {
        browser.test.sendMessage("matched_fallback:host", location.href);
      }
    },
    "matched_fallback:glob.js": () => {
      if (location.protocol === "data:") {
        browser.test.sendMessage("matched_fallback:glob", location.href);
      }
    },
    "never_matched.js": () => {
      browser.test.fail(`Unexpected match at: ${location.href}`);
    },
  };

  const extension = ExtensionTestUtils.loadExtension({ manifest, files });
  await extension.startup();

  const DATA_URL_FRAME = "data:,iframe_data";
  const DATA_URL = `data:text/html,<iframe src="${DATA_URL_FRAME}"></iframe>`;

  let frame = document.createElement("iframe");
  frame.src = DATA_URL;
  document.body.appendChild(frame);

  // The outer data: URL iframe should match via precursor (mochi.test)
  is(
    await extension.awaitMessage("matched_fallback:host"),
    DATA_URL,
    "match_origin_as_fallback matches data: URL iframe via matches"
  );
  is(
    await extension.awaitMessage("matched_fallback:glob"),
    DATA_URL,
    "match_origin_as_fallback matches data: URL iframe via glob"
  );

  // The nested iframe inside the data: URL should also match
  is(
    await extension.awaitMessage("matched_fallback:host"),
    DATA_URL_FRAME,
    "match_origin_as_fallback matches nested frame in data: URL iframe via matches"
  );
  is(
    await extension.awaitMessage("matched_fallback:glob"),
    DATA_URL_FRAME,
    "match_origin_as_fallback matches nested frame in data: URL iframe via glob"
  );

  frame.remove();

  await extension.unload();
});

// Test top-level data: URLs without a precursor principal, such as when the
// user navigates to a data:-URL from the address bar.
add_task(async function top_level_data_url_without_precursor() {
  const manifest = {
    content_scripts: [
      {
        // match_about_blank may match top-level about:blank documents with a
        // null principal, as a special case. This same logic was expanded to
        // top-level data:-URLs in bug 1451463 (undocumented!).
        match_about_blank: true,
        matches: ["*://*/*"],
        js: ["match_about_blank:wildcard.js"],
        all_frames: true,
        run_at: "document_start",
      }, {
        // This is special compared to *://*/*: The data:-schema is part of
        // <all_urls>, so even if the origin were to somehow not match anything,
        // then <all_urls> + match_origin_as_fallback could potentially match
        // data:-URLs without precursor principal, such as when the user
        // navigates to a data:-URL from the address bar.
        match_origin_as_fallback: true,
        matches: ["<all_urls>"],
        include_globs: ["data:,iframe_data"],
        all_frames: true,
        js: ["matched_fallback:glob_iframe.js"],
        run_at: "document_start",
      }, {
        // There is a special case similar to about:blank which is also tested
        // by top_level_about_blank in test_ext_contentscript_about_blank.html:
        // When the top-level document is opaque, and 'matches' matches any URL,
        // then data:-URLs are injected (even though there is no precursor to
        // match).
        // Note: this does not match the iframe, because the "origin" to be used
        // for matching is the data:-URL of the iframe, and "*://*/*" does not
        // match data:-URLs, unlike <all_urls>.
        match_origin_as_fallback: true,
        matches: ["*://*/*"],
        all_frames: true,
        js: ["matched_fallback:wildcard.js"],
        run_at: "document_start",
      }, {
        // Sanity check: include_globs can also reject a match.
        match_origin_as_fallback: true,
        matches: ["<all_urls>"],
        include_globs: ["data:,not-matching"],
        all_frames: true,
        js: ["never_matched.js"],
        run_at: "document_start",
      }, {
        // Not expected to match: fall through to data:-URL matching only
        // happens when match_origin_as_fallback is true, not when
        // match_about_blank is true.
        match_about_blank: true,
        matches: ["<all_urls>"],
        include_globs: ["data:*"],
        all_frames: true,
        js: ["never_matched2.js"],
        run_at: "document_start",
      },
    ],
  };

  const files = {
    "match_about_blank:wildcard.js": () => {
      if (location.protocol === "data:") {
        browser.test.sendMessage("match_about_blank:wildcard", location.href);
      }
    },
    "matched_fallback:wildcard.js": () => {
      if (location.protocol === "data:") {
        browser.test.sendMessage("matched_fallback:wildcard", location.href);
      }
    },
    "matched_fallback:glob_iframe.js": () => {
      if (location.protocol === "data:") {
        browser.test.sendMessage("matched_fallback:glob_iframe", location.href);
      }
    },
    "never_matched.js": () => {
      browser.test.fail(`Unexpected match at: ${location.href}`);
    },
    "never_matched2.js": () => {
      browser.test.fail(`Unexpected match 2 at: ${location.href}`);
    },
  };

  const extension = ExtensionTestUtils.loadExtension({ manifest, files });
  await extension.startup();

  const DATA_URL_FRAME = "data:,iframe_data";
  const DATA_URL = `data:text/html,<iframe src="${DATA_URL_FRAME}"></iframe>`;

  let tab = await AppTestDelegate.openNewForegroundTab(window, DATA_URL, true);

  // match_about_blank with wildcard matches top-level data: URLs (bug 1451463)
  is(
    await extension.awaitMessage("match_about_blank:wildcard"),
    DATA_URL,
    "match_about_blank with wildcard matches data:-URL popup"
  );
  // Notably: match_about_blank:wildcard for DATA_URL_FRAME is not sent, because
  // data:-URLs are not really supported with match_about_blank. Undocumented
  // support for top-level data:-URLs was introduced in bug 1451463.

  is(
    await extension.awaitMessage("matched_fallback:wildcard"),
    DATA_URL,
    "match_origin_as_fallback matches data:-URL popup without http(s) origin"
  );

  is(
    await extension.awaitMessage("matched_fallback:glob_iframe"),
    DATA_URL_FRAME,
    "match_origin_as_fallback matches data:-URL frame by data:-glob pattern"
  );

  await AppTestDelegate.removeTab(window, tab);

  await extension.unload();
});

</script>

</body>
</html>
