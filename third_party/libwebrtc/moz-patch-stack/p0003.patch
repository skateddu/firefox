From: =?UTF-8?q?Erik=20Spr=C3=A5ng?= <sprang@webrtc.org>
Date: Wed, 12 Nov 2025 05:37:17 +0100
Subject: (cherry-pick-branch-heads/7499) [Merge-143] Cap ACD filter kernel
 settings to legal [0, 40] bound.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This avoids a CHECK seen to trigger in production with certain hardware
encoders. Since they may not have a reasonable upper bound on the QP,
unlike typical reference software encoders, this hasn't been observer
until recently.

(cherry picked from commit 82b44db82984028c99c0adb2cf2c0b3bd7766dcb)

No-Iwyu: Broken iwyu bot.
Bug: chromium:417844679, chromium:459965817
Fixed: chromium:462016089
Change-Id: I406032a4e7cd462a7d5b1ab02a7a099f7ffc84b2
Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/423680
Reviewed-by: Stefan Holmer <stefan@webrtc.org>
Commit-Queue: Erik Språng <sprang@webrtc.org>
Auto-Submit: Erik Språng <sprang@webrtc.org>
Cr-Original-Commit-Position: refs/heads/main@{#46165}
Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/426880
Commit-Queue: Henrik Boström <hbos@webrtc.org>
Cr-Commit-Position: refs/branch-heads/7499@{#2}
Cr-Branched-From: 1dfd30cf31a029cd127674a11e65c54c07afaf5d-refs/heads/main@{#46046}
---
 video/corruption_detection/BUILD.gn           |  1 +
 .../generic_mapping_functions.cc              | 27 +++++++++++++++----
 .../generic_mapping_functions_unittest.cc     | 12 ++++++---
 3 files changed, 31 insertions(+), 9 deletions(-)

diff --git a/video/corruption_detection/BUILD.gn b/video/corruption_detection/BUILD.gn
index d3054d7db5..7a81ec47d8 100644
--- a/video/corruption_detection/BUILD.gn
+++ b/video/corruption_detection/BUILD.gn
@@ -49,6 +49,7 @@ rtc_library("generic_mapping_functions") {
     "../../api/video/corruption_detection:filter_settings",
     "../../api/video_codecs:video_codecs_api",
     "../../rtc_base:checks",
+    "../../rtc_base:logging",
   ]
 }
 
diff --git a/video/corruption_detection/generic_mapping_functions.cc b/video/corruption_detection/generic_mapping_functions.cc
index 5215f15c1d..2ee52c5e0f 100644
--- a/video/corruption_detection/generic_mapping_functions.cc
+++ b/video/corruption_detection/generic_mapping_functions.cc
@@ -10,12 +10,14 @@
 
 #include "video/corruption_detection/generic_mapping_functions.h"
 
+#include <algorithm>
 #include <cmath>
 
 #include "api/video/corruption_detection/corruption_detection_filter_settings.h"
 #include "api/video/video_codec_type.h"
 #include "api/video_codecs/video_codec.h"
 #include "rtc_base/checks.h"
+#include "rtc_base/logging.h"
 
 namespace webrtc {
 namespace {
@@ -60,23 +62,38 @@ double RationalFunction(double a, double b, double c, int qp) {
 // Maps QP to the optimal standard deviation for the Gausian kernel.
 // Observe that the values below can be changed unnoticed.
 double MapQpToOptimalStdDev(int qp, VideoCodecType codec_type) {
+  double std_dev;
   switch (codec_type) {
     case VideoCodecType::kVideoCodecVP8:
-      return ExponentialFunction(0.006, 0.01857465, -4.26470513, qp);
+      std_dev = ExponentialFunction(0.006, 0.01857465, -4.26470513, qp);
+      break;
     case VideoCodecType::kVideoCodecVP9:
-      return RationalFunction(1, -257, 0.3, qp);
+      std_dev = RationalFunction(1, -257, 0.3, qp);
+      break;
     case VideoCodecType::kVideoCodecAV1:
-      return RationalFunction(0.69, -256, 0.42, qp);
+      std_dev = RationalFunction(0.69, -256, 0.42, qp);
+      break;
     case VideoCodecType::kVideoCodecH264:
-      return ExponentialFunction(0.016, 0.13976962, -1.40179328, qp);
+      std_dev = ExponentialFunction(0.016, 0.13976962, -1.40179328, qp);
+      break;
     case VideoCodecType::kVideoCodecH265:
       // Observe that these values are currently only tuned for software libx265
       // in "preset ultrafast -tune zerolatency" mode.
-      return RationalFunction(1.6, -52, 0.1, qp);
+      std_dev = RationalFunction(1.6, -52, 0.1, qp);
+      break;
     default:
       RTC_FATAL() << "Codec type " << CodecTypeToPayloadString(codec_type)
                   << " is not supported.";
   }
+  if (std_dev < 0.0 || std_dev > 40.0) {
+    RTC_LOG(LS_VERBOSE) << "Generic frame instrumentation settings generated "
+                           "incorrect std_dev value for codec "
+                        << CodecTypeToPayloadString(codec_type) << " and QP "
+                        << qp << ": " << std_dev
+                        << ". Capping to legal bound [0, 40]";
+    std_dev = std::min(std::max(std_dev, 0.0), 40.0);
+  }
+  return std_dev;
 }
 
 }  // namespace
diff --git a/video/corruption_detection/generic_mapping_functions_unittest.cc b/video/corruption_detection/generic_mapping_functions_unittest.cc
index 2817570945..33c62527da 100644
--- a/video/corruption_detection/generic_mapping_functions_unittest.cc
+++ b/video/corruption_detection/generic_mapping_functions_unittest.cc
@@ -55,8 +55,9 @@ TEST(GenericMappingFunctionsTest, TestVp9) {
   EXPECT_THAT(GetCorruptionFilterSettings(/*qp=*/200, kCodecType),
               FieldsAre(DoubleNear(3.8088, kMaxAbsoluteError), kLumaThreshold,
                         kChromaThresholdVp9));
+  // Cap to legal range [0, 40].
   EXPECT_THAT(GetCorruptionFilterSettings(/*qp=*/255, kCodecType),
-              FieldsAre(DoubleNear(127.8, kMaxAbsoluteError), kLumaThreshold,
+              FieldsAre(DoubleNear(40.0, kMaxAbsoluteError), kLumaThreshold,
                         kChromaThresholdVp9));
 }
 
@@ -71,8 +72,9 @@ TEST(GenericMappingFunctionsTest, TestAv1) {
   EXPECT_THAT(GetCorruptionFilterSettings(/*qp=*/200, kCodecType),
               FieldsAre(DoubleNear(2.8842, kMaxAbsoluteError), kLumaThreshold,
                         kChromaThresholdAv1));
+  // Cap to legal range [0, 40].
   EXPECT_THAT(GetCorruptionFilterSettings(/*qp=*/255, kCodecType),
-              FieldsAre(DoubleNear(176.37, kMaxAbsoluteError), kLumaThreshold,
+              FieldsAre(DoubleNear(40, kMaxAbsoluteError), kLumaThreshold,
                         kChromaThresholdAv1));
 }
 
@@ -84,8 +86,9 @@ TEST(GenericMappingFunctionsTest, TestH264) {
   EXPECT_THAT(GetCorruptionFilterSettings(/*qp=*/30, kCodecType),
               FieldsAre(DoubleNear(4.3047, kMaxAbsoluteError), kLumaThreshold,
                         kChromaThresholdH264));
+  // Cap to legal range [0, 40].
   EXPECT_THAT(GetCorruptionFilterSettings(/*qp=*/51, kCodecType),
-              FieldsAre(DoubleNear(81.0346, kMaxAbsoluteError), kLumaThreshold,
+              FieldsAre(DoubleNear(40.0, kMaxAbsoluteError), kLumaThreshold,
                         kChromaThresholdH264));
 }
 
@@ -97,8 +100,9 @@ TEST(GenericMappingFunctionsTest, TestH265) {
   EXPECT_THAT(GetCorruptionFilterSettings(/*qp=*/30, kCodecType),
               FieldsAre(DoubleNear(2.2818, kMaxAbsoluteError), kLumaThreshold,
                         kChromaThresholdH265));
+  // Cap to legal range [0, 40].
   EXPECT_THAT(GetCorruptionFilterSettings(/*qp=*/51, kCodecType),
-              FieldsAre(DoubleNear(81.7, kMaxAbsoluteError), kLumaThreshold,
+              FieldsAre(DoubleNear(40.0, kMaxAbsoluteError), kLumaThreshold,
                         kChromaThresholdH265));
 }
 
